#!/usr/bin/env python3
from pyasn1.codec.der.encoder import encode
from pyasn1_modules import rfc3161, rfc5652
from pyasn1.type import univ, char, useful
import base64
import sys

digest_b64url = sys.argv[1]
serial = int(sys.argv[2])
sig_b64url = sys.argv[3]
gen_time = sys.argv[4]  # Format ISO: 2025-06-20T12:30:00Z

digest_bytes = base64.urlsafe_b64decode(digest_b64url + '==')
signature = base64.urlsafe_b64decode(sig_b64url + '==')

# -- Build TSTInfo
tst_info = rfc3161.TSTInfo()
tst_info.setComponentByName('version', 1)
tst_info.setComponentByName('policy', univ.ObjectIdentifier('1.2.3.4.5.6.7')) 
# fake
mi = rfc3161.MessageImprint()
mi.setComponentByName('hashAlgorithm',
rfc5652.DigestAlgorithmIdentifier().setComponentByName('algorithm',
univ.ObjectIdentifier('2.16.840.1.101.3.4.2.1')))  # sha256
mi.setComponentByName('hashedMessage', digest_bytes)
tst_info.setComponentByName('messageImprint', mi)
tst_info.setComponentByName('serialNumber', univ.Integer(serial))
tst_info.setComponentByName('genTime', useful.GeneralizedTime(gen_time))

# -- Encapsulate TSTInfo in ContentInfo
content_info = rfc5652.ContentInfo()
content_info.setComponentByName('contentType', rfc5652.id_signedData)
signed_data = rfc5652.SignedData()
signed_data.setComponentByName('version', 1)
signed_data.setComponentByName('encapContentInfo',
rfc5652.EncapsulatedContentInfo().setComponentByName('eContentType',
rfc3161.id_ct_TSTInfo).setComponentByName('eContent', encode(tst_info)))
# Omitting certificates and signerInfos
content_info.setComponentByName('content', signed_data)

# -- Full TimeStampResp
resp = rfc3161.TimeStampResp()
resp.setComponentByName('status',
rfc3161.PKIStatusInfo().setComponentByName('status', 0))
resp.setComponentByName('timeStampToken', content_info)

# Output DER
with open("reconstitue.tsr", "wb") as f:
    f.write(encode(resp))
print("Fichier reconstitue.tsr généré")

