#!/bin/bash
################################################################
# Copyright (c) 2025 Thibault Le Paul (@tibolpol)              #
# Licence MIT - https://opensource.org/license/mit/            #
#                                                              #
# <$* : help genkey { list2tgz clean inject date sign verify } #
# <stdin : data to sign | timestamp                            #
# <$HOME/.ssh/ed25519_*.pem : Ed25519 keys                     #
# <$HOME/.ssh/id_rsa.pub : identity clear text                 #
# >stdout : signed | timestamp data                            #
# >stderr : errors                                             #
################################################################

################################################################
# MAIN                                                         #
# <$* : help genkey { list2tgz clean inject date sign verify } #
# <stdin  : input.raw                                          #
# >stdout : output.raw                                         #
################################################################
main() {
  if (( $# ));then
    local args="$*"
    args="${args//date/inject date}"
    args="${args//sign/inject sign}"
    help "$args" # suite du pipe
  else
    local filetype="$(lookup main)"
    if [[ $filetype =~ pdf ]];then
      read -r -p "$myname { clean inject date sign verify } ? " </dev/tty
      [ -n "$REPLY" ] &&
        local args="$REPLY" &&
        args="${args//date/inject date}" &&
        args="${args//sign/inject sign}" &&
        clean "$args" < lookup.main
    else
      help help # affiche l'aide
    fi
    rm -f lookup.main
  fi | tee >(success "main output: $(lookup)" >&2)
}

##################
# Aide en ligne  #
# >stderr : help #
##################
help() {
  strip help "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0)) ; then

    # pas d'entrée ni de pipe suivant
    exec </dev/null
    dead "$args" >/dev/null

    cat <<EOF >&2
$(echo -e "\033[1;36m")SealGood - $(_ "Document signing and timestamping via") OpenSSL + TSA$(echo -e "\033[0m")

$(_ "Usage"): $myname help genkey { list2tgz clean inject date sign verify }

$(_ "COMMANDS"):
  genkey         $(_ "Generate a new password-protected ed25519 key pair")
  help           $(_ "Show this help")
  list2tgz       $(_ "Apply pipeline to each filename read from") stdin
  clean          $(_ "Extract original content without SEALGOOD tags")
  inject         $(_ "Inject SealGood payload into PDF, HTML or PEM file")
  date           $(_ "Timestamp a document via trusted third party (TSA)")
  sign           $(_ "Sign a document with your private key")
  verify         $(_ "Verify document signature and timestamp")

  $(_ "Commands compose into an implicitly ordered pipeline"):

  clean | inject | date | sign | verify
    - $(_ "reads data from") stdin
    - $(_ "comments progress on") stderr
    - $(_ "writes data to") stdout

       +-- clean | inject | date | sign | verify
     /
  list2tgz
    - $(_ "reads filenames from") stdin
    - $(_ "sends each file through pipeline")
    - $(_ "comments progress on") stderr
    - $(_ "outputs a tar+gzip archive to") stdout
    - $(_ "introduces a hash into each signed or timestamped filename")

  inject $(_ "respects existing SealGood payload");
  date sign $(_ "implicitly perform") inject;
  date sign $(_ "respect existing signature/timestamp");
  list2tgz sign $(_ "asks private key passphrase only once").
    
$(_ "Examples"):
  $(basename "$0") sign date < contract.pdf > contract_sealgood.pdf
  $(basename "$0") verify    < contract_sealgood.pdf
  $(basename "$0") list2tgz sign <<EOD > archive.tgz
  contract1.pdf
  contract2.pdf
  contract3.pdf
  EOD

$(_ "Files used"):
  \$HOME/.ssh/ed25519_private_*.pem  : $(_ "signer private keys")
  \$HOME/.ssh/ed25519_public_*.pem   : $(_ "associated public keys")
  \$HOME/.ssh/id_rsa.pub             : $(_ "signer identity declaration")
  https://freetsa.org/files/cacert.pem : $(_ "TSA root certificate")

$(_ "See also") : https://github.com/tibolpol/sealgood
EOF
  else
    genkey "$args" # fonction suivante
  fi
}

####################################
# Génération des clés ed25519      #
# <stdin                           #
# <$* : fonctions à exécuter       #
# > $HOME/.ssh/ed25519_private.pem #
# > $HOME/.ssh/ed25519_public.pem  #
####################################
genkey() {
  strip genkey "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then

    # pas d'entrée ni de pipe suivant
    exec </dev/null
    dead "$args" >/dev/null

    [ -s "$PRIVATE_KEY" ] && die 4 "$(_ "%s already exists and has non-zero size" "$PRIVATE_KEY")"

    read -p "$(_ "This key will be used to sign documents, please enter signer name"): " SIGNATAIRE

    PRIVATE_KEY="$HOME"/.ssh/ed25519_private_${SIGNATAIRE// /_}.pem
    PUBLIC_KEY="$HOME"/.ssh/ed25519_public_${SIGNATAIRE// /_}.pem

    [ -s $PRIVATE_KEY ] && die 4 "$(_ "%s already exists and has non-zero size" "$PRIVATE_KEY")"

    # 1. Générer la clé privée chiffrée avec AES-256
    # 2. Extraire la clé publique
    openssl genpkey -algorithm ed25519 -aes-256-cbc -out "$PRIVATE_KEY"
    openssl pkey -in "$PRIVATE_KEY" -pubout -out "$PUBLIC_KEY"

    fmt <<END
$(_ "You can (should) publish %s on a trusted public repository and mention its URL in %s" "$PUBLIC_KEY" "$HOME/.ssh/ed25519_public_${SIGNATAIRE// /_}.url")
$(_ "This way your document signatures will be non-repudiable and therefore accepted").
END
  else
    umask go=      # fichiers temporaires privés
    list2tgz "$args" # suite du pipe s'occupe des data
  fi
}

##############################
# <stdin                     #
# <$* : fonctions à exécuter #
# >stdout : output.raw       #
##############################
list2tgz() {
  strip list2tgz "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    #####################
    # PASS just-in-time #
    #####################
    if strip sign "$args" >/dev/null;then
      coproc passrelay {
        read -r # attend le ask sur &"$fdpassask"
        cat >/dev/null & # puis vide
        if [ "$REPLY" = ask ] ; then 
          read -r -s -p "$(_ "Private key password"): " PASS </dev/tty
          echo >&2
          while :; do echo "$PASS"; done
        fi
      }
      exec {fdpassin}<&"${passrelay[0]}" {fdpassask}>&"${passrelay[1]}"
      # signale le coproc à verify
      export fdpassin fdpassask
    fi
    file2tgz
    rm -f tsr.bin signature.bin # pas de prompt exit_policy
  else
    clean "$args"
  fi
}

############################################
# Sélection de fichiers à traiter en batch #
# <stdin : liste de fichiers               #
# >stdout : .tgz du résultat du pipeline   #
############################################
file2tgz(){
  tar --remove-files -zcf - -T <(
    export fdverifyout
    while read -r FILE; do
      ((FNR++))
      export FNR
      if (cd "$INITIAL_DIR" && cat < "$FILE") > input.list2tgz 2>/dev/null ;then
        # Nommage en sortie, pattern _sealgood:<sha256sum:8>
        export OUTFILE="$(basename "$FILE")"
        local filetype="$(lookup < input.list2tgz)"
        if [[ $filetype =~ sealgood ]];then
          hash=$(clean clean < input.list2tgz | sha256sum | cut -c1-8)
          base="$(echo "${OUTFILE%.*}" | sed -E 's/_sealgood(:[a-zA-Z0-9]+)?$//')"
          if [[ "$base" == "$OUTFILE" ]]; then
            OUTFILE="${base}_sealgood:${hash}"
          else
            OUTFILE="${base}_sealgood:${hash}.${OUTFILE##*.}"
          fi
          # Vérification de l'ancien nom
          if [[ "$FILE" =~ _sealgood:[a-zA-Z0-9]+(\..*)?$ ]] && [[ ! "$FILE" =~ _sealgood:$hash(\..*)?$ ]]; then
            alert="$(_ "Hash in old filename %s doesn't match document hash" "$(basename "$FILE")")"
            alert "$alert"
            alert "$FNR: $alert" 2>&"$fdverifyout"
          fi
        fi
        # Exécution du pipe
        step "list2tgz $FILE -> $OUTFILE"
        clean "$args" <input.list2tgz >"$OUTFILE"
        # décision d'ajouter le fichier en sortie
        local newfiletype="$(lookup < "$OUTFILE")"
        if ( #set -x
          [        -s "$OUTFILE"            ] &&  # le fichier n'est pas vide
            { [[ $filetype != $newfiletype ]] ||  # le status sealgood change
              [[ $newfiletype =~ sealgood  ]];})  # le nouveau status est ou reste sealgood
        then
          echo "$OUTFILE" # pris en charge par --remove-files
        else
          rm -f "$OUTFILE"
        fi
      else
        alert "stdin:$FNR: $FILE $(_ "is not readable")"
      fi
    done
  ) {fdverifyout}> >(
    # Résumé des messages de vérification à la fin
    cat > fdverifyout
    [ -s fdverifyout ] &&
      step "$(_ "Verification summary")"
      cat fdverifyout >&2
      step "$(_ "End of verifications")"
  )
}

######################################
# Restitue le input.raw sans payload #
# <stdin                             #
# <$* : fonctions à exécuter         #
# >stdout : original                 #
# <stdin après exécution : payload   #
######################################
clean() {
  strip clean "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    local filetype="$(lookup clean)"
    if [[ $filetype =~ sealgood ]];then
      if [[ $filetype =~ gzip ]];then
        local count=$(gzip -cd lookup.clean | awk '/### BEGIN SEALGOOD /{state=1}state && /^wc *: /{print $5;exit}')
        head -c "$count"
      else 
        awk '/^(<!-- )?### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}'
      fi
    else
      cat
    fi <lookup.clean 
    rm -f lookup.clean
  else
    cat
  fi | inject "$args"
}

##############################################################
# Injection d'informations cachées dans une copie du fichier #
# <stdin                                                     #
# <$*     : fonctions à exécuter                             #
# >stdout : copie avec payload & PLACEHOLDER                 #
##############################################################
inject() {
  strip inject "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    local filetype="$(lookup inject)"
    # Le type d'injection dépend de filetype
    if [[ $filetype =~ pdf ]];then
      inject_pdf       "$filetype"
    elif [[ $filetype =~ xml  ]];then
      inject_xml      "$filetype"
    elif [[ $filetype =~ html ]];then
      inject_xml      "$filetype"
    elif [[ $filetype =~ gzip ]];then
      inject_gzip     "$filetype"
    elif [[ $filetype =~ PEM..$(_ "Public key") ]];then
      inject_after_eod "$filetype"
    else
      warning "$(_ "I don't know how to inject into") mimetype: $filetype"
      cat
    fi <lookup.inject | tee >(echo "inject output: $(lookup)" >&2)
    rm -f lookup.inject
  else
    cat
  fi | date "$args"
}

#######################################################
# Horodatage d'un document (payload, hash, signature) #
# <stdin                                              #
# <$* : fonctions à exécuter                          #
# >stdout : copie horodatée avec payload              #
#######################################################
date() {
  strip date "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    local filetype="$(lookup date)"
    if [[ $filetype =~ sealgood ]];then
      if [[ $filetype =~ gzip ]];then
        if zgrep -aq "^PLACEHOLDER_UNTIMESTAMP_FILE" lookup.date; then
          local count=$(gzip -cd lookup.date | awk '/### BEGIN SEALGOOD /{state=1}state && /^wc *: /{print $5;exit}')
          head -c "$count"
          gzip -cd | sed "s|^PLACEHOLDER_UNTIMESTAMP_FILE|$(<lookup.date timestamp | base64 -w 0)|" | gzip -nc
        else
          cat
          warning "$(_ "Already timestamped")"
        fi
      else
        if grep -aq "^PLACEHOLDER_UNTIMESTAMP_FILE" lookup.date; then
          sed "s|^PLACEHOLDER_UNTIMESTAMP_FILE|$(<lookup.date timestamp | base64 -w 0)|"
        else
          cat
          warning "$(_ "Already timestamped")"
        fi
      fi <lookup.date
    else
      die $LINENO "assert failure"
    fi | tee >(echo "date output: $(lookup)" >&2)
    rm -f lookup.date
  else
    cat
  fi | sign "$args"
}

######################################################
# Signature d'un document (payload, hash, signature) #
# stdin   : data à signer                            #
# <$*     : fonctions à exécuter                     #
# <$PRIVATE_KEY : nom local de la clé privée         #
# >stdout : copie signée avec payload                #
######################################################
sign() {
  strip sign "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    local filetype="$(lookup sign)"
    if [[ $filetype =~ sealgood ]];then
      if [[ $filetype =~ gzip ]];then
        if zgrep -aq "^PLACEHOLDER_UNSIGNED_FILE" lookup.sign; then
          grep -q 'empty password' <( openssl pkey -in "$PRIVATE_KEY" -noout -passin pass: </dev/null 2>&1) || die 4 "$(_ "%s is not encrypted" "$PRIVATE_KEY")"
          local count=$(gzip -cd lookup.sign | awk '/### BEGIN SEALGOOD /{state=1}state && /^wc *: /{print $5;exit}')
          head -c "$count"
          gzip -cd | sed "s|^PLACEHOLDER_UNSIGNED_FILE|$(<lookup.sign signraw | base64 -w 0)|" | gzip -nc
        else
          cat
          warning "$(_ "Already signed")"
        fi
      else
        if grep -aq "^PLACEHOLDER_UNSIGNED_FILE" lookup.sign; then
          grep -q 'empty password' <( openssl pkey -in "$PRIVATE_KEY" -noout -passin pass: </dev/null 2>&1) || die 4 "$(_ "%s is not encrypted" "$PRIVATE_KEY")"
          sed "s|^PLACEHOLDER_UNSIGNED_FILE|$(<lookup.sign signraw | base64 -w 0)|"
        else
          cat
          warning "$(_ "Already signed")"
        fi
      fi <lookup.sign
    else
      die $LINENO "assert failure"
    fi | tee >(echo "sign output: $(lookup)" >&2)
    rm -f lookup.sign
  else
    cat
  fi | verify "$args"
}

##################################################
# Vérification de sealgood signature & timestamp #
# <stdin  : data avec payload                    #
# <$*     : fonctions à exécuter                 #
# >stderr : statut de la vérification            #
# >stdout : copie de data                        #
##################################################
verify() {
  strip verify "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    local filetype="$(lookup verify)"
    rm -f tsr.bin signature.bin
    if [[ $filetype =~ sealgood ]];then
      # Extraction des éléments du document
      step "$(_ "Extracting verification elements")"

      # 1. Extraction du contenu original
      if [[ $filetype =~ gzip ]]; then
        local count=$(gzip -cd lookup.verify | awk '/### BEGIN SEALGOOD /{state=1}state && /^wc *: /{print $5;exit}')
        head -c "$count"
        zcat >payload
      else
        tee >(awk '/^(<!-- )?### BEGIN SEALGOOD /{state=1}state{print}/^### END SEALGOOD /{state=0}' >payload) | clean clean
      fi <lookup.verify >original_data
      success "$(_ "Original content extracted")"

      # 2. Extraction de la signature
      SIGNATURE=$( awk '/Élément de vérification 4 : signature du hash/,/base64/' payload | grep -vE '^#|base64|PLACEHOLDER' | tr -d ' \n')
      if [ -z "$SIGNATURE" ]; then
        warning "$(_ "Signature not found in document")"
      else
        echo "$SIGNATURE" | base64 -d > signature.bin
        success "$(_ "Signature extracted and decoded")"
        # 3. Extraction de la clé publique
        PUBLIC_KEY=$(awk '/-----BEGIN PUBLIC KEY-----/,/-----END PUBLIC KEY-----/' payload | head -n 3)
        if [ -z "$PUBLIC_KEY" ]; then
          warning "$(_ "Public key not found in document")"
        else
          echo "$PUBLIC_KEY" > public_key.pem
          success "$(_ "Public key extracted")"
        fi
      fi

      # 4. Extraction du TSR
      TSR=$(awk '/Élément de vérification 2 : encodage 64 du tsr/,/base64/' payload | grep -vE '^#|base64|PLACEHOLDER' | tr -d ' \n')
      if [ -z "$TSR" ]; then
        warning "$(_ "TSR not found in document")"
      else
        echo "$TSR" | base64 -d > tsr.bin
        success "$(_ "TSR extracted and decoded")"

        # 5. Extraction du certificat TSA
        TSA_CERT=$(awk '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/' payload)
        if [ -z "$TSA_CERT" ]; then
          warning "$(_ "TSA certificate not found - Downloading from") freetsa.org"
          curl -s https://freetsa.org/files/cacert.pem -o tsa_cert.pem || warning "$(_ "Failed to download TSA certificate")"
        else
          echo "$TSA_CERT" > tsa_cert.pem
          success "$(_ "TSA certificate extracted")"
        fi
      fi

      if [ -s tsa_cert.pem ] || [ -s public_key.pem ]; then 

        # Vérification de la signature
        if [ -s public_key.pem ] && [ -s signature.bin ] && [ -s original_data ]; then
          step "$(_ "Verifying digital signature")"
          (
            set -x
            openssl pkeyutl -verify -pubin -inkey public_key.pem -sigfile signature.bin -in original_data -rawin &> sig_result ||
            openssl pkeyutl -verify -pubin -inkey public_key.pem -sigfile signature.bin -in <(openssl dgst -sha256 -binary original_data) &> sig_result
          )
          SIG_VERIFY=$?

          if (( SIG_VERIFY  == 0 )); then
            success "$(_ "Signature successfully verified")"
            SIGNATURE_VALID=true
          else
            alert "$(_ "Signature verification failed")"
            cat sig_result >&2
            SIGNATURE_VALID=false
          fi
        fi

        # Vérification de l'horodatage
        if [ -s tsr.bin ] && [ -s tsa_cert.pem ] && [ -s original_data ] ; then
          step "$(_ "Verifying TSA timestamp")"
          (
            set -x
            openssl ts -verify -in tsr.bin -CAfile tsa_cert.pem -data original_data &> ts_result
          )
          DATE_VERIFY=$?

          if (( DATE_VERIFY == 0 )); then
            success "$(_ "Timestamp successfully verified")"
            TIMESTAMP_VALID=true
          else
            alert "$(_ "Timestamp verification failed")"
            cat ts_result >&2
            TIMESTAMP_VALID=false
          fi
              
          # Affichage des détails de l'horodatage
          echo -e "\n$(_ "Timestamp details"):" >&2
          openssl ts -reply -in tsr.bin -text | grep -A2 "Time stamp:" >&2
        fi
      fi

      # Résumé final
      step "$(_ "Verification summary")"

      echo -e "$(_ "Signature status"): $([ "$SIGNATURE_VALID" = true ] && success "$(_ "VALID")" 2>&1 || { [ "$SIGNATURE_VALID" = false ] && alert "$(_ "INVALID")" || warning "$(_ "MISSING")" 2>&1 ; } 2>&1)" >&2
      echo -e "$(_ "Timestamp status"): $([ "$TIMESTAMP_VALID" = true ] && success "$(_ "VALID")" 2>&1 || { [ "$TIMESTAMP_VALID" = false ] && alert "$(_ "INVALID")" || warning "$(_ "MISSING")" 2>&1 ; } 2>&1)" >&2

      # signé, horodaté et intact
      # signé et intact
      # horodaté et intact
      # ni signé ni horodaté 
      # altéré
      if   [ "$SIGNATURE_VALID" = true ] && [ "$TIMESTAMP_VALID" = true ]; then
        success "$(_ "Document") $(_ "is signed, timestamped and intact")"
        ((fdverifyout)) && success "$FNR: $OUTFILE $(_ "is signed, timestamped and intact")" 2>&$fdverifyout
      elif [ "$SIGNATURE_VALID" = true ] && [ "$TIMESTAMP_VALID" = "" ]; then
        success "$(_ "Document") $(_ "is signed and intact")"
        ((fdverifyout)) && success "$FNR: $OUTFILE $(_ "is signed and intact")" 2>&$fdverifyout
      elif [ "$SIGNATURE_VALID" = ""   ] && [ "$TIMESTAMP_VALID" = true ]; then
        success "$(_ "Document") $(_ "is timestamped and intact")"
        ((fdverifyout)) && success "$FNR: $OUTFILE $(_ "is timestamped and intact")" 2>&$fdverifyout
      elif [ "$SIGNATURE_VALID" = ""   ] && [ "$TIMESTAMP_VALID" = "" ]; then
        warning "$(_ "Document") $(_ "is neither signed nor timestamped")"
        ((fdverifyout)) && success "$FNR: $OUTFILE $(_ "is neither signed nor timestamped")" 2>&$fdverifyout
      else
        alert "$(_ "Document") $(_ "has been altered")"
        ((fdverifyout)) && alert "$FNR: $OUTFILE $(_ "has been altered")" 2>&$fdverifyout
      fi
      cat lookup.verify
    else
      cat lookup.verify
    fi | tee >(echo "verify output: $(lookup)" >&2)
  else
    cat
  fi | dead "$args"
}

######################################
# Arguments restants en bout de pipe #
######################################
dead(){
  (( $# && $(eval echo -n "$*" | wc -c) )) &&
    warning "$(_ "Remaining arguments \"%s\" could not be processed" "$*")"
  cat
}

#########################################
# Consommation de la chaîne d'arguments #
# <$1   : mot                           #
# <$*:2 : autres                        #
# >stdout : autres sans mot             #
# >$?   : présence mot                  #
#########################################
strip() {
  local word="$1"
  local input="${*:2}"  # Get all arguments after the first one
  if [[ "$input" =~ (^|[[:space:]])"$word"($|[[:space:]]) ]]; then
    echo -n "${input//$word/}"
    return 0
  else
    echo -n "$input"
    return 1
  fi
}

#############################################################################
# PAYLOAD : Explications détaillées non intrusives sur les vues du document #
# C'est juste du plaintext qui commence et termine par des balises          #
# <stdin : original data
# <$REPOS_KEY : nom web de la clé publique                                  #
# <$PUBLIC_KEY : nom local de la clé publique                               #
# <$HOME/.ssh/id_rsa.pub : emplacement du nom du signataire                 #
# <https://freetsa.org/files/cacert.pem : cartificat racine de la TSA       #
# >stdout : payload                                                         #
#############################################################################
get_payload() {
[ -s original_data ] || cat > original_data
cat <<EOD
### BEGIN SEALGOOD SIGNATURE ###
SealGood - $(_ "The 100% DIY Document Authenticator")
https://github.com/tibolpol/sealgood/

$(_ "WARNING: As with a physical document, verifying authenticity and
signature is harder than signing. The key is to guarantee that the means
exist, that they are freely and publicly available, and that they use
recognized, documented and standard tools at each step for transparency of
proof. Each step can therefore be done manually with this guide. A lightweight
integration is proposed on the site"): https://github.com/tibolpol/sealgood

$(_ "Verification tools"):
- $(_ "POSIX standard"): awk, base64, file, wc
- $(_ "non-POSIX but recognized standard"): openssl

$(_ "The signed document has the following properties"):
file -bi : $(<original_data lookup)
wc       : $(<original_data wc -)

$(_ "Signer declaration"): $(cut -d' ' -f3- < $HOME/.ssh/id_rsa.pub)
$(_ "Signer ed25519 public key"): $REPOS_KEY

$(_ "WARNING! The readable signer declaration here could have been forged.
What makes it valid is the trusted third party associated with this key
(website, personal exchange, blockchain, public key sealed and published on an
irrefutable address by the signer)").

$(_ "The signature and timestamp remain valid as long as the content outside
the BEGIN SEALGOOD and END SEALGOOD tags is not altered").

$(_ "If verification element 4 is not a PLACEHOLDER but a base64 signature
code, the signer's identity can be proven").

## $(_ "Verification element") 1: $(_ "Key presentation URL, presented by the
signer as trusted, so that they cannot repudiate this signature").
# $REPOS_KEY

## $(_ "Verification element") 2: $(_ "Signer's ed25519 public key")
# $(_ "COPY the three lines below and PASTE into file /tmp/%s") "$(basename "$PUBLIC_KEY")"
# $(_ "or download %s to /tmp/%s") "$REPOS_KEY" "$(basename "$PUBLIC_KEY")"
-----BEGIN PUBLIC KEY-----
$(awk '/^-----BEGIN PUBLIC KEY/{getline;print;exit}' "$PUBLIC_KEY")
-----END PUBLIC KEY-----

## $(_ "Verification element") 3: $(_ "Unsigned file without payload") ($(_ "just before signing"))
awk '/^### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}' < "\$filename.pdf" > /tmp/\$filename.pdf # $(_ "Unsigned file without payload")

## $(_ "Verification element") 4: $(_ "Signature of the original file hash")
# $(_ "COPY the line below and PASTE into file") /tmp/sig.64
PLACEHOLDER_UNSIGNED_FILE
base64 -d < /tmp/sig.64 > /tmp/sig.bin

## $(_ "Final verification"): $(_ "Current file hash and validation of match using public key")
# $(_ "Links the file hash to the private key owner's trust chain")
openssl dgst -sha256 -binary /tmp/file.pdf >/tmp/hash.bin
openssl pkeyutl -verify -pubin -inkey /tmp/\$(basename "\$PUBLIC_KEY") -sigfile /tmp/sig.bin -in /tmp/hash.bin # $(_ "verify signature")

### BEGIN SEALGOOD TIMESTAMP ###

$(_ "If verification element 2 is not a PLACEHOLDER but a base64 code, the signing date can be proven").

## $(_ "Verification element") 1: $(_ "TSA authority root certificate")
# $(_ "COPY the three lines below and PASTE into file") /tmp/freetsa_cacert.pem
# $(_ "or download %s to %s" https://freetsa.org/files/cacert.pem /tmp/freetsa_cacert.pem)
$(
  [ -s freetsa_cacert.pem ] ||
  curl -s https://freetsa.org/files/cacert.pem |
  awk '$1~"^-----"{if(buf){print buf;buf=""};print;next}{buf=buf $0}END{printf("%s",buf)}' >freetsa_cacert.pem
  cat freetsa_cacert.pem
)
openssl x509 -reply -text -in /tmp/freetsa_cacert.pem # $(_ "show certificate details")

## $(_ "Verification element") 2: $(_ "Base64 encoding of TSA-validated tsr")
# $(_ "COPY the line below and PASTE into file") /tmp/tsr.64
PLACEHOLDER_UNTIMESTAMPED_FILE
base64 -d < /tmp/tsr.64 > /tmp/tsr.bin
openssl ts -reply -text -in /tmp/tsr.bin # $(_ "show timestamp details")

## $(_ "Verification element") 3: $(_ "Untimestamped file without payload") ($(_ "just before timestamping"))
awk '/^### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}' < "\$filename.pdf" > /tmp/\$filename.pdf # $(_ "Unsigned file without payload")

## $(_ "Final verification"): $(_ "Current file hash and validation of match using tsr and certificate chain")
# $(_ "Links the file hash to the tsr date in the TSA trust chain")
openssl ts -verify -in /tmp/tsr.bin -CAfile /tmp/freetsa_cacert.pem -data /tmp/\$filename.pdf # $(_ "verify timestamp")

### END SEALGOOD ###
EOD
}

########################
# Calcule un timestamp #
# <stdin               #
# >stdout : tsr.bin    #
########################
timestamp() {
  clean clean | openssl ts -query -data /dev/stdin -sha256 -cert |
  curl -s -H "Content-Type: application/timestamp-query" --data-binary @- --output - https://freetsa.org/tsr
}

###########################
# Calcule une signature   #
# <stdin                  #
# >stdout : signature.bin #
###########################
signraw() {
  clean clean >original_data
  if ((fdpassin)); then
    echo ask >&"$fdpassask"
    openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -rawin -in original_data -passin stdin <&"$fdpassin"
  else
    openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -rawin -in original_data
  fi
}

###########################
# Calcule une signature   #
# <stdin                  #
# >stdout : signature.bin #
###########################
signdgst(){
  # Cette signature n'est pas compatible avec le schéma de clé
  clean clean | openssl dgst -sha256 -binary >hash.bin
  if ((fdpassin)); then
    echo ask >&"$fdpassask"
    openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -in hash.bin -passin stdin <&"$fdpassin"
  else
    openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -in hash.bin
  fi
}

##############################################################
# Injection d'informations cachées dans une copie du fichier #
# <$1 : filetype                                             #
# <stdin                                                     #
# >stdout : copie avec payload & PLACEHOLDER                 #
##############################################################
inject_after_eod() {
  tee original_data
  [[ $1 =~ sealgood ]] || get_payload < original_data
}

############################################################################################################################
# Injection d'informations cachées dans une copie du fichier pdf                                                           #
# https://stackoverflow.com/questions/11896858/does-the-eof-in-a-pdf-have-to-appear-within-the-last-1024-bytes-of-the-file #
# Un peu limite mais pas rencontré de cas rhédibitoire et clean rend le pdf récupérable anyway                             #
# <$1 : filetype                                                                                                           #
# <stdin                                                                                                                   #
# >stdout : copie avec payload & PLACEHOLDER                                                                               #
############################################################################################################################
inject_pdf() {
  inject_after_eod "$@"
}

##################################################################
# Injection d'informations cachées dans une copie du HTML | XML  #
# <$1 : filetype                                                 #
# <stdin                                                         #
# >stdout : copie avec payload & PLACEHOLDER                     #
##################################################################
inject_xml() {
  tee original_data
  [[ $1 =~ sealgood ]] || echo "<!-- $(get_payload < original_data) -->"
}

##################################################################
# Injection d'informations cachées dans une copie du gzip        #
# https://www.gnu.org/software/gzip/manual/gzip#Advanced-usage   #
# <$1 : filetype                                                 #
# <stdin                                                         #
# >stdout : copie avec payload & PLACEHOLDER                     #
##################################################################
inject_gzip() {
  tee original_data
  [[ $1 =~ sealgood ]] || get_payload < original_data | gzip -c
}

###############################################################
# Sortie du script                                            #
# Prompt pour conserver le répertoire temporaire après verify #
# Désactivé par list2tgz en supprimant les fichiers           #
###############################################################
exit_policy(){
  [ -s tsr.bin ] || [ -s signature.bin ] &&
  </dev/tty read -r -p $'\n\033[1;36m'"=== $(_ "Keep temporary directory for inspection") [yN] ? "$'\033[0m' &&
  [[ $REPLY == y ]] &&
  warning "$PWD $(_ "is kept")" &&
  ls -l >&2 ||
  rm -rf "$TMPDIR"
}

###########################################
# Scan l'input pour valider les actions   #
# <$1 : pour nommage de copie de l'entrée #
# <stdin                                  #
# >stdout : type de fichier               #
# >lookup.$1  : copie stdin               #
###########################################
lookup() {
  sfx=${1:-$RANDOM}
  cat >lookup."$sfx"
  local result="$(file -b -i lookup."$sfx")"
  if [[ $result =~ application/octet-stream ]];then
    if grep -aq '^%PDF-' lookup."$sfx" && grep -aq '^%%EOF' lookup."$sfx" ; then
      result="${result/octet-stream/pdf+octet-stream}"
    else
      result="${result/octet-stream/$(check_crypto_file "$sfx" "$result")+octet-stream}"
    fi
  fi
  if [[ $result =~ application/gzip ]];then
    if zgrep -aq '### BEGIN SEALGOOD' lookup."$sfx";then
      result="${result/gzip/sealgood+gzip}"
    fi
  elif [[ $result =~ text/xml ]];then
    if grep -aq '^<!-- ### BEGIN SEALGOOD' lookup."$sfx";then
      result="${result/xml/sealgood+xml}"
    fi
  elif [[ $result =~ text/html ]];then
    if grep -aq '^<!-- ### BEGIN SEALGOOD' lookup."$sfx";then
      result="${result/html/sealgood+html}"
    fi
  elif [[ $result =~ application/pdf ]];then
    if grep -aq '^### BEGIN SEALGOOD' lookup."$sfx";then
      result="${result/pdf/sealgood+pdf}"
    elif pdftotext lookup."$sfx" - 2>/dev/null | grep -aq '^### BEGIN SEALGOOD';then
      result="${result/pdf/sealgood-old+pdf}"
    fi
  elif [[ $result =~ text/plain ]];then
    if grep -aq '^-----BEGIN' lookup."$sfx";then
      result="${result/plain/$(check_crypto_file "$sfx" "$result")+plain}"
    fi
  fi
  if [[ ! $result =~ sealgood ]];then
    if grep -aEq '^(<!-- )?### BEGIN SEALGOOD' lookup."$sfx";then
      result="${result/\//\/sealgood+}"
    fi
  fi
  echo "$result"
  [ "$sfx" = "$1" ] || rm -f lookup."$sfx"
}

###########################################
# Lookup des types de fichier crypto      #
# <$1 : pour nommage de copie de l'entrée #
# <$2 : known filetype                    #
# <lookup.$1                              #
# >stdout : type de fichier               #
###########################################
check_crypto_file() {
  local result=""
  if [[ $2 =~ octet-stream ]] ; then
    if (openssl pkcs12 -password pass: -in lookup."$1" -info -noout;(($?==1 || $?==0))) &>/dev/null ; then
      result="[PKCS#12] $(_ "Key+certificate container")"
    elif (openssl x509 -password pass: -in lookup."$1" -noout;(($?==1 || $?==0))) &>/dev/null; then
      #local algo=$(openssl x509 -password pass: -in lookup."$1" -noout -text | grep "Public Key Algorithm")
      result="[X.509] $(_ "Certificate")"
    elif (openssl pkey -password pass: -in lookup."$1" -noout;(($?==1 || $?==0))) &>/dev/null; then
      #local algo=$(openssl pkey -in "$file" -noout -text | grep "algorithm")
      result="[PKEY] $(_ "Private key")"
    elif (openssl req -password pass: -in lookup."$1" -noout;(($?==1 || $?==0))) &>/dev/null; then
      result="[CSR] $(_ "Certificate signing request")"
    fi
  elif [[ $2 =~ text/plain ]] ; then
    if grep -q "BEGIN CERTIFICATE REQUEST" lookup."$1"; then
      result="[CSR] $(_ "Certificate signing request")"
    elif grep -q "BEGIN OPENSSH PRIVATE KEY" lookup."$1"; then
      result="[OPENSSH] $(_ "Private key")"
    elif grep -q "BEGIN PRIVATE KEY" lookup."$1"; then
      result="[PEM] $(_ "UNENCRYPTED private key")"
    elif grep -q "BEGIN ENCRYPTED PRIVATE KEY" lookup."$1"; then
      result="[PEM] $(_ "ENCRYPTED private key")"
    elif grep -q "BEGIN PUBLIC KEY" lookup."$1"; then
      result="[PEM] $(_ "Public key")"
    elif grep -q "BEGIN RSA PUBLIC KEY" lookup."$1"; then
      result="[RSA] $(_ "Public key")"
    elif grep -q "BEGIN RSA PRIVATE KEY" lookup."$1"; then
      result="[RSA] $(_ "Private key")"
    elif gdalinfo lookup."$1" &>/dev/null; then
      result="$(_ "DEM file (GDAL format)")"
    elif grep -q "BEGIN CERTIFICATE" lookup."$1"; then
      result="[PEM] $(_ "Certificate")"
    fi
  fi
  echo "$result"
}

#####################
# Envoi de messages #
#####################
die() {
  rc="$1"
  shift
  alert "$(basename "$0") rc=$rc $*"
  exit "$rc"
}
alert() {
  echo -e "\033[1;31m$(_ "ERROR"): $*\033[0m" >&2
}
step() {
  echo -e "\n\033[1;36m=== $* ===\033[0m" >&2
}
success() {
  echo -e "\033[1;32m$*\033[0m" >&2
}
warning() {
  echo -e "\033[1;33m$*\033[0m" >&2
}

_(){ gettext "$@"; }

###########################################################################################
# Principes de design :                                                                   #
# Un seul répertoire temporaire commun.                                                   #
# N'écrit aucun fichier hors du répertoire temporaire (sauf genkey)                       #
# Les fonctions principales sont conçues pour se composer en Unix pipe.                   #
# Pas d'éléments partagés entre fonctions, tout passe par le pipe, sauf exception.        #
# Chaque fonction contrôle la suite de son propre pipe.                                   #
# Chaque fonction commence par un fork décidant si elle doit s'exécuter ou être passante. #
# $args est consommée au fil du pipe.                                                     #
# L'ordre du pipe complet est :                                                           #
#                                                                                         #
# main | help | getkey | list2tgz | clean | inject | date | signe | verify | dead         #
#          \      \        \                                                              #
#            dead   dead     file2tgz | clean | inject | date | signe | verify | dead     #
###########################################################################################

################################
# Vérification des dépendances #
################################
for cmd in awk openssl base64 curl; do
  command -v $cmd &> /dev/null ||
  die 16 "$LINENO: $(_ "Missing command"): $cmd"
done </dev/null

export myname="$(basename "$0")"
export mydir="$(dirname "$0")"
export TEXTDOMAIN="$myname"
export TEXTDOMAINDIR="$(realpath "$mydir/locale")" 
export TMPDIR="$(mktemp -d)"
trap exit_policy EXIT
cd "$TMPDIR" || die 16 "$LINENO: FATAL"
INITIAL_DIR="$OLDPWD"
shopt -s nullglob
list=("$HOME"/.ssh/ed25519_private*.pem)
export PRIVATE_KEY="${list[0]}" # nom local de la clé privée
list=("$HOME"/.ssh/ed25519_public*.pem)
export PUBLIC_KEY="${list[0]}" # nom local de la clé publique
export REPOS_KEY="$(cat < "$HOME"/.ssh/ed25519_public*.url)" # nom web de la clé publique

main "$@" | cat
