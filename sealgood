#!/bin/bash
################################################
# <$1 : genkey | sign | date                   #
# <stdin : data to sign | timestamp            #
# <$HOME/.ssh/ed25519_*.pem : Ed25519 keys     #
# <$HOME/.ssh/id_rsa.pub : identity clear text #
# >stdout : signed | timestamp data            #
# >stderr : errors                             #
################################################

################################################################
# MAIN                                                         #
# <$* : help genkey { list2tgz clean inject date sign verify } #
# <stdin  : input.raw                                          #
# >stdout : output.raw                                         #
################################################################
main() {
  if (( $# ));then
    local args="$*"
    args="${args//date/inject date}"
    args="${args//sign/inject sign}"
    help "$args" # suite du pipe
  else
    local filetype="$(lookup main)"
    if [[ $filetype =~ pdf ]];then
      read -r -p "$myname { clean inject date sign verify } ? " </dev/tty
      [ -n "$REPLY" ] &&
        local args="$REPLY" &&
        args="${args//date/inject date}" &&
        args="${args//sign/inject sign}" &&
        clean "$args" < lookup.main
    else
      help help # affiche l'aide
    fi
    rm -f lookup.main
  fi | tee >(success "main output: $(lookup)" >&2)
}

##################
# Aide en ligne  #
# >stderr : help #
##################
help() {
  strip help "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0)) ; then

    # pas d'entrée ni de pipe suivant
    exec </dev/null
    dead "$args" >/dev/null

    cat <<EOF >&2
$(echo -e "\033[1;36mSealGood - Signature et horodatage de documents via OpenSSL + TSA\033[0m")

Usage : $myname help genkey { list2tgz clean inject date sign verify }

COMMANDES :
  genkey         Génère une nouvelle paire de clés ed25519 protégée par mot de passe
  help           Affiche l'aide
  list2tgz       Applique le pipe à chaque fichier dont le nom est lu sur stdin
  clean          Extrait le contenu original sans les balises SEALGOOD
  inject         Injecte le payload SealGood dans un fichier PDF ou PEM
  date           Horodate un document via un tiers de confiance (TSA)
  sign           Signe un document avec votre clé privée
  verify         Vérifie la signature et l'horodatage d'un document

  Les commandes se composent en pipeline implicitement ordonné :

  clean | inject | date | sign | verify
    - lit les données sur stdin
    - commente la progression sur stderr
    - écrit les données sur stdout

       +-- clean | inject | date | sign | verify
     /
  list2tgz
    - lit les noms de fichiers sur stdin
    - envoie chaque fichier au pipeline
    - commente la progression sur stderr
    - écrit une archive tar+gzip sur stdout

  inject respecte le payload SealGood déjà présent ;
  date sign opèrent implicitement inject ;
  date sign respectent une signature/horodatage déjà présente ;
  list2tgz sign ne demande qu'une fois la passphrase de la clé privée.
    
Exemples :
  $(basename "$0") sign date < contrat.pdf > contrat_sealgood.pdf
  $(basename "$0") verify    < contrat_sealgood.pdf
  $(basename "$0") list2tgz sign <<EOD > archive.tgz
  contrat1.pdf
  contrat2.pdf
  contrat3.pdf
  EOD

Fichiers utilisés :
  \$HOME/.ssh/ed25519_private_*.pem  : clés privées signataires
  \$HOME/.ssh/ed25519_public_*.pem   : clés publiques associées
  \$HOME/.ssh/id_rsa.pub             : déclaration d'identité du signataire
  https://freetsa.org/files/cacert.pem : certificat racine TSA

Voir aussi : https://github.com/tibolpol/sealgood
EOF
  else
    genkey "$args" # fonction suivante
  fi
}

####################################
# Génération des clés ed25519      #
# <stdin                           #
# <$* : fonctions à exécuter       #
# > $HOME/.ssh/ed25519_private.pem #
# > $HOME/.ssh/ed25519_public.pem  #
####################################
genkey() {
  strip genkey "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then

    # pas d'entrée ni de pipe suivant
    exec </dev/null
    dead "$args" >/dev/null

    [ -s "$PRIVATE_KEY" ] && die 4 "$PRIVATE_KEY existe déjà et a une taille non nulle"

    read -p"Cette clé servira à signer des documents, mentionnez le nom du signataire : " SIGNATAIRE

    PRIVATE_KEY="$HOME"/.ssh/ed25519_private_${SIGNATAIRE// /_}.pem
    PUBLIC_KEY="$HOME"/.ssh/ed25519_public_${SIGNATAIRE// /_}.pem

    [ -s $PRIVATE_KEY ] && die 4 "$PRIVATE_KEY existe déjà et a une taille non nulle"

    # 1. Générer la clé privée chiffrée avec AES-256
    # 2. Extraire la clé publique
    openssl genpkey -algorithm ed25519 -aes-256-cbc -out "$PRIVATE_KEY"
    openssl pkey -in "$PRIVATE_KEY" -pubout -out "$PUBLIC_KEY"

    fmt <<END
Vous pouvez (devez) diffuser $PUBLIC_KEY
sur un référentiel public de confiance, et mentionner son URL dans
$HOME/.ssh/ed25519_public_${SIGNATAIRE// /_}.url
Ainsi vos signatures de document seront non répudiables, donc acceptées.
END
  else
    umask go=      # fichiers temporaires privés
    list2tgz "$args" # suite du pipe s'occupe des data
  fi
}

##############################
# <stdin                     #
# <$* : fonctions à exécuter #
# >stdout : output.raw       #
##############################
list2tgz() {
  strip list2tgz "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    #####################
    # PASS just-in-time #
    #####################
    if strip sign "$args" >/dev/null;then
      coproc passrelay {
        read -r # attend le ask sur &"$fdpassask"
        cat >/dev/null & # puis vide
        if [ "$REPLY" = ask ] ; then 
          read -r -s -p "Mot de passe de la clé privée : " PASS </dev/tty
          echo >&2
          while :; do echo "$PASS"; done
        fi
      }
      exec {fdpassin}<&"${passrelay[0]}" {fdpassask}>&"${passrelay[1]}"
      # signale le coproc à verify
      export fdpassin fdpassask
    fi
    file2tgz
    rm -f tsr.bin signature.bin # pas de prompt exit_policy
  else
    clean "$args"
  fi
}

############################################
# Sélection de fichiers à traiter en batch #
# <stdin : liste de fichiers               #
# >stdout : .tgz du résultat du pipeline   #
############################################
file2tgz(){
  tar --remove-files -zcf - -T <(
    export fdverifyout
    while read -r FILE; do
      ((FNR++))
      export FNR
      if (cd "$INITIAL_DIR" && cat < "$FILE") > input.list2tgz 2>/dev/null ;then
        # Nommage en sortie, pattern _sealgood:<sha256sum:8>
        export OUTFILE="$(basename "$FILE")"
        local filetype="$(lookup < input.list2tgz)"
        if [[ $filetype =~ sealgood ]];then
          hash=$(clean clean < input.list2tgz | sha256sum | cut -c1-8)
          base="$(echo "${OUTFILE%.*}" | sed -E 's/_sealgood(:[a-zA-Z0-9]+)?$//')"
          if [[ "$base" == "$OUTFILE" ]]; then
            OUTFILE="${base}_sealgood:${hash}"
          else
            OUTFILE="${base}_sealgood:${hash}.${OUTFILE##*.}"
          fi
          # Vérification de l'ancien nom
          if [[ "$FILE" =~ _sealgood:[a-zA-Z0-9]+(\..*)?$ ]] && [[ ! "$FILE" =~ _sealgood:$hash(\..*)?$ ]]; then
            alert="Le hash de l'ancien nom $(basename "$FILE") ne correspond pas au hash du document"
            alert "$alert"
            alert "$FNR: $alert" 2>&"$fdverifyout"
          fi
        fi
        # Exécution du pipe
        step "list2tgz $FILE -> $OUTFILE"
        clean "$args" <input.list2tgz >"$OUTFILE"
        # décision d'ajouter le fichier en sortie
        local newfiletype="$(lookup < "$OUTFILE")"
        if ( #set -x
          [        -s "$OUTFILE"            ] &&  # le fichier n'est pas vide
            { [[ $filetype != $newfiletype ]] ||  # le status sealgood change
              [[ $newfiletype =~ sealgood  ]];})  # le nouveau status est ou reste sealgood
        then
          echo "$OUTFILE" # pris en charge par --remove-files
        else
          rm -f "$OUTFILE"
        fi
      else
        alert "stdin:$FNR: $FILE n'est pas lisible"
      fi
    done
  ) {fdverifyout}> >(
    # Résumé des messages de vérification à la fin
    cat > fdverifyout
    [ -s fdverifyout ] &&
      step "Résumé des vérifications"
      cat fdverifyout >&2
      step "Fin des vérifications"
  )
}

######################################
# Restitue le input.raw sans payload #
# <stdin                             #
# <$* : fonctions à exécuter         #
# >stdout : original                 #
# <stdin après exécution : payload   #
######################################
clean() {
  strip clean "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    local filetype="$(lookup clean)"
    if [[ $filetype =~ sealgood ]];then
      if [[ $filetype =~ gzip ]];then
        local count=$(gzip -cd lookup.clean | awk '/### BEGIN SEALGOOD /{state=1}state && /^wc *: /{print $5;exit}')
        head -c "$count"
      else 
        awk '/^(<!-- )?### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}'
      fi
    else
      cat
    fi <lookup.clean 
    rm -f lookup.clean
  else
    cat
  fi | inject "$args"
}

##############################################################
# Injection d'informations cachées dans une copie du fichier #
# <stdin                                                     #
# <$*     : fonctions à exécuter                             #
# >stdout : copie avec payload & PLACEHOLDER                 #
##############################################################
inject() {
  strip inject "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    local filetype="$(lookup inject)"
    # Le type d'injection dépend de filetype
    if [[ $filetype =~ pdf ]];then
      inject_pdf       "$filetype"
    elif [[ $filetype =~ xml  ]];then
      inject_xml      "$filetype"
    elif [[ $filetype =~ html ]];then
      inject_xml      "$filetype"
    elif [[ $filetype =~ gzip ]];then
      inject_gzip     "$filetype"
    elif [[ $filetype =~ PEM..Clé.publique ]];then
      inject_after_eod "$filetype"
    else
      warning "Je ne sais pas injecter dans le mimetype : $filetype"
      cat
    fi <lookup.inject | tee >(echo "inject output: $(lookup)" >&2)
    rm -f lookup.inject
  else
    cat
  fi | date "$args"
}

#######################################################
# Horodatage d'un document (payload, hash, signature) #
# <stdin                                              #
# <$* : fonctions à exécuter                          #
# >stdout : copie horodatée avec payload              #
#######################################################
date() {
  strip date "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    local filetype="$(lookup date)"
    if [[ $filetype =~ sealgood ]];then
      if [[ $filetype =~ gzip ]];then
        if zgrep -aq "^PLACEHOLDER.*HORODATÉ" lookup.date; then
          local count=$(gzip -cd lookup.date | awk '/### BEGIN SEALGOOD /{state=1}state && /^wc *: /{print $5;exit}')
          head -c "$count"
          gzip -cd | sed "s|^PLACEHOLDER.*HORODATÉ|$(<lookup.date timestamp | base64 -w 0)|" | gzip -nc
        else
          cat
          warning "Déjà horodaté"
        fi
      else
        if grep -aq "^PLACEHOLDER.*HORODATÉ" lookup.date; then
          sed "s|^PLACEHOLDER.*HORODATÉ|$(<lookup.date timestamp | base64 -w 0)|"
        else
          cat
          warning "Déjà horodaté"
        fi
      fi <lookup.date
    else
      die $LINENO "assert failure"
    fi | tee >(echo "date output: $(lookup)" >&2)
    rm -f lookup.date
  else
    cat
  fi | sign "$args"
}

######################################################
# Signature d'un document (payload, hash, signature) #
# stdin   : data à signer                            #
# <$*     : fonctions à exécuter                     #
# <$PRIVATE_KEY : nom local de la clé privée         #
# >stdout : copie signée avec payload                #
######################################################
sign() {
  strip sign "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    local filetype="$(lookup sign)"
    if [[ $filetype =~ sealgood ]];then
      if [[ $filetype =~ gzip ]];then
        if zgrep -aq "^PLACEHOLDER.*SIGNÉ" lookup.sign; then
          grep -q 'empty password' <( openssl pkey -in "$PRIVATE_KEY" -noout -passin pass: </dev/null 2>&1) || die 4 "$PRIVATE_KEY non chiffrée"
          local count=$(gzip -cd lookup.sign | awk '/### BEGIN SEALGOOD /{state=1}state && /^wc *: /{print $5;exit}')
          head -c "$count"
          gzip -cd | sed "s|^PLACEHOLDER.*SIGNÉ|$(<lookup.sign signraw | base64 -w 0)|" | gzip -nc
        else
          cat
          warning "Déjà signé"
        fi
      else
        if grep -aq "^PLACEHOLDER.*SIGNÉ" lookup.sign; then
          grep -q 'empty password' <( openssl pkey -in "$PRIVATE_KEY" -noout -passin pass: </dev/null 2>&1) || die 4 "$PRIVATE_KEY non chiffrée"
          sed "s|^PLACEHOLDER.*SIGNÉ|$(<lookup.sign signraw | base64 -w 0)|"
        else
          cat
          warning "Déjà signé"
        fi
      fi <lookup.sign
    else
      die $LINENO "assert failure"
    fi | tee >(echo "sign output: $(lookup)" >&2)
    rm -f lookup.sign
  else
    cat
  fi | verify "$args"
}

##################################################
# Vérification de sealgood signature & timestamp #
# <stdin  : data avec payload                    #
# <$*     : fonctions à exécuter                 #
# >stderr : statut de la vérification            #
# >stdout : copie de data                        #
##################################################
verify() {
  strip verify "$@" > args
  local rargs=$? args="$(cat args)"
  if ((rargs == 0));then
    local filetype="$(lookup verify)"
    rm -f tsr.bin signature.bin
    if [[ $filetype =~ sealgood ]];then
      # Extraction des éléments du document
      step "Extraction des éléments de vérification"

      # 1. Extraction du contenu original
      if [[ $filetype =~ gzip ]]; then
        local count=$(gzip -cd lookup.verify | awk '/### BEGIN SEALGOOD /{state=1}state && /^wc *: /{print $5;exit}')
        head -c "$count"
        zcat >payload
      else
        tee >(awk '/^(<!-- )?### BEGIN SEALGOOD /{state=1}state{print}/^### END SEALGOOD /{state=0}' >payload) | clean clean
      fi <lookup.verify >original_data
      success "Contenu original extrait"

      # 2. Extraction de la signature
      SIGNATURE=$( awk '/Élément de vérification 4 : signature du hash/,/base64/' payload | grep -vE '^#|base64|PLACEHOLDER' | tr -d ' \n')
      if [ -z "$SIGNATURE" ]; then
        warning "Signature introuvable dans le document"
      else
        echo "$SIGNATURE" | base64 -d > signature.bin
        success "Signature extraite et décodée"
        # 3. Extraction de la clé publique
        PUBLIC_KEY=$(awk '/-----BEGIN PUBLIC KEY-----/,/-----END PUBLIC KEY-----/' payload | head -n 3)
        if [ -z "$PUBLIC_KEY" ]; then
          warning "Clé publique introuvable dans le document"
        else
          echo "$PUBLIC_KEY" > public_key.pem
          success "Clé publique extraite"
        fi
      fi

      # 4. Extraction du TSR
      TSR=$(awk '/Élément de vérification 2 : encodage 64 du tsr/,/base64/' payload | grep -vE '^#|base64|PLACEHOLDER' | tr -d ' \n')
      if [ -z "$TSR" ]; then
        warning "TSR introuvable dans le document"
      else
        echo "$TSR" | base64 -d > tsr.bin
        success "TSR extrait et décodé"

        # 5. Extraction du certificat TSA
        TSA_CERT=$(awk '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/' payload)
        if [ -z "$TSA_CERT" ]; then
          warning "Certificat TSA introuvable - Téléchargement depuis freetsa.org"
          curl -s https://freetsa.org/files/cacert.pem -o tsa_cert.pem || warning "Échec du téléchargement du certificat TSA"
        else
          echo "$TSA_CERT" > tsa_cert.pem
          success "Certificat TSA extrait"
        fi
      fi

      if [ -s tsa_cert.pem ] || [ -s public_key.pem ]; then 

        # Vérification de la signature
        if [ -s public_key.pem ] && [ -s signature.bin ] && [ -s original_data ]; then
          step "Vérification de la signature numérique"
          (
            set -x
            openssl pkeyutl -verify -pubin -inkey public_key.pem -sigfile signature.bin -in original_data -rawin &> sig_result ||
            openssl pkeyutl -verify -pubin -inkey public_key.pem -sigfile signature.bin -in <(openssl dgst -sha256 -binary original_data) &> sig_result
          )
          SIG_VERIFY=$?

          if (( SIG_VERIFY  == 0 )); then
            success "Signature vérifiée avec succès"
            SIGNATURE_VALID=true
          else
            alert "Échec de la vérification de la signature"
            cat sig_result >&2
            SIGNATURE_VALID=false
          fi
        fi

        # Vérification de l'horodatage
        if [ -s tsr.bin ] && [ -s tsa_cert.pem ] && [ -s original_data ] ; then
          step "Vérification de l'horodatage TSA"
          (
            set -x
            openssl ts -verify -in tsr.bin -CAfile tsa_cert.pem -data original_data &> ts_result
          )
          DATE_VERIFY=$?

          if (( DATE_VERIFY == 0 )); then
            success "Horodatage vérifié avec succès"
            TIMESTAMP_VALID=true
          else
            alert "Échec de la vérification de l'horodatage"
            cat ts_result >&2
            TIMESTAMP_VALID=false
          fi
              
          # Affichage des détails de l'horodatage
          echo -e "\nDétails de l'horodatage:" >&2
          openssl ts -reply -in tsr.bin -text | grep -A2 "Time stamp:" >&2
        fi
      fi

      # Résumé final
      step "Résumé de la vérification"

      echo -e "Statut de la signature: $([ "$SIGNATURE_VALID" = true ] && success "VALIDE" 2>&1 || { [ "$SIGNATURE_VALID" = false ] && alert "INVALIDE" || warning "ABSENT" 2>&1 ; } 2>&1)" >&2
      echo -e "Statut de l'horodatage: $([ "$TIMESTAMP_VALID" = true ] && success "VALIDE" 2>&1 || { [ "$TIMESTAMP_VALID" = false ] && alert "INVALIDE" || warning "ABSENT" 2>&1 ; } 2>&1)" >&2

      # signé, horodaté et intact
      # signé et intact
      # horodaté et intact
      # ni signé ni horodaté 
      # altéré
      if   [ "$SIGNATURE_VALID" = true ] && [ "$TIMESTAMP_VALID" = true ]; then
        success "Le document est signé, horodaté et intact"
        ((fdverifyout)) && success "$FNR: $OUTFILE est signé, horodaté et intact" 2>&"$fdverifyout"
      elif [ "$SIGNATURE_VALID" = true ] && [ "$TIMESTAMP_VALID" = "" ]; then
        success "Le document est signé et intact"
        ((fdverifyout)) && success "$FNR: $OUTFILE est signé et intact" 2>&"$fdverifyout"
      elif [ "$SIGNATURE_VALID" = ""   ] && [ "$TIMESTAMP_VALID" = true ]; then
        success "Le document est horodaté et intact"
        ((fdverifyout)) && success "$FNR: $OUTFILE est horodaté et intact" 2>&"$fdverifyout"
      elif [ "$SIGNATURE_VALID" = ""   ] && [ "$TIMESTAMP_VALID" = "" ]; then
        warning "Le document n'est pas signé ni horodaté"
        ((fdverifyout)) && success "$FNR: $OUTFILE n'est pas signé ni horodatée" 2>&"$fdverifyout"
      else
        alert "Le document a été altéré"
        ((fdverifyout)) && alert "$FNR: $OUTFILE a été altéré" 2>&"$fdverifyout"
      fi
      < lookup.verify tee >(echo "verify output: $(lookup)" >&2)
    fi
  else
    cat
  fi | dead "$args"
}

######################################
# Arguments restants en bout de pipe #
######################################
dead(){
  (( $# && $(eval echo -n "$*" | wc -c) )) &&
    warning "Les arguments restants \"$*\" n'ont pas pu être traités"
  cat
}

#########################################
# Consommation de la chaîne d'arguments #
# <$1   : mot                           #
# <$*:2 : autres                        #
# >stdout : autres sans mot             #
# >$?   : présence mot                  #
#########################################
strip() {
  local word="$1"
  local input="${*:2}"  # Get all arguments after the first one
  if [[ "$input" =~ (^|[[:space:]])"$word"($|[[:space:]]) ]]; then
    echo -n "${input//$word/}"
    return 0
  else
    echo -n "$input"
    return 1
  fi
}

#############################################################################
# PAYLOAD : Explications détaillées non intrusives sur les vues du document #
# C'est juste du plaintext qui commence et termine par des balises          #
# <stdin : original data
# <$REPOS_KEY : nom web de la clé publique                                  #
# <$PUBLIC_KEY : nom local de la clé publique                               #
# <$HOME/.ssh/id_rsa.pub : emplacement du nom du signataire                 #
# <https://freetsa.org/files/cacert.pem : cartificat racine de la TSA       #
# >stdout : payload                                                         #
#############################################################################
get_payload() {
[ -s original_data ] || cat > original_data
cat <<EOD
### BEGIN SEALGOOD SIGNATURE ###
SealGood - The 100% DIY Document Authenticator
https://github.com/tibolpol/sealgood/

AVERTISSEMENT :  Comme pour un document matériel, vérifier l'authenticité et
la signature est plus difficile que de signer.  L'essentiel est de garantir
que les moyens existent, qu'ils soient disponibles gratuitement et
publiquement, et qu'ils utilisent à chaque étape des outils reconnus,
documentés et standards, pour la transparence de la preuve.  Chaque étape est
donc réalisable à la main à l'aide de ce guide. Une intégration légère est
proposée sur le site https://github.com/tibolpol/sealgood

Outils de vérification :
- standard POSIX : awk, base64, file, wc
- non POSIX mais standard reconnu : openssl

Le document signé a les propriétés suivantes :
file -bi : $(<original_data lookup)
wc       : $(<original_data wc -)

Déclaration de signataire : $(cut -d' ' -f3- < "$HOME"/.ssh/id_rsa.pub)
Clé publique ed25519 du signataire : $REPOS_KEY

ATTENTION !  La déclaration de signataire lisible ici pourrait avoir été forgée.
Ce qui fait foi est le tiers de confiance associé à cette clé (site web,
échange personnel, blockchain, clé publique scellée et publiée sur
une adresse irrépudiable par le signataire).

La signature et l'horodatage restent valides tant que le contenu hors des
balises BEGIN SEALGOOD et END SEALGOOD n'est pas altéré.

Si l'élément de vérification 4 n'est pas un PLACEHOLDER mais un code de
signature en base64, l'identité du signataire peut être prouvée.

## Élément de vérification 1 :  URL de présentation de la clé, présentée par
# le signataire comme de confiance, afin que celui-ci ne fasse pas opposition
# à cette signature (non répudiation) :
# $REPOS_KEY

## Élément de vérification 2 :  clé publique ed25519 du signataire
# COPIER trois lignes ci-dessous et COLLER dans le fichier /tmp/$(basename "$PUBLIC_KEY")
# ou télécharger $REPOS_KEY vers /tmp/$(basename "$PUBLIC_KEY")
-----BEGIN PUBLIC KEY-----
$(awk '/^-----BEGIN PUBLIC KEY/{getline;print;exit}' "$PUBLIC_KEY")
-----END PUBLIC KEY-----

## Élément de vérification 3 : fichier non signé sans payload (juste avant la signature)
awk '/^### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}' < "\$nom_de_fichier.pdf" > /tmp/\$nom_de_fichier.pdf # fichier non signé sans payload

## Élément de vérification 4 : signature du hash original du fichier
# COPIER la ligne ci-dessous et COLLER dans le fichier /tmp/sig.64
PLACEHOLDER - FICHIER NON SIGNÉ
base64 -d < /tmp/sig.64 > /tmp/sig.bin

## Vérification finale : hash du fichier actuel et validation de la correspondance à l'aide de la clé publique
# Lie le hash du fichier à la chaîne de confiance du possesseur de la clé privée
openssl dgst -sha256 -binary /tmp/file.pdf >/tmp/hash.bin
openssl pkeyutl -verify -pubin -inkey /tmp/\$(basename "\$PUBLIC_KEY") -sigfile /tmp/sig.bin -in /tmp/hash.bin # vérifier la signature

### BEGIN SEALGOOD TIMESTAMP ###

Si l'élément de vérification 2 n'est pas un PLACEHOLDER mais un code en
base64, la date de signature peut être prouvée.

## Élément de vérification 1 : certificat racine de l'autorité TSA
# COPIER les trois lignes ci-dessous et COLLER dans le fichier /tmp/freetsa_cacert.pem
# ou télécharger https://freetsa.org/files/cacert.pem vers /tmp/freetsa_cacert.pem
$(
  [ -s freetsa_cacert.pem ] ||
  curl -s https://freetsa.org/files/cacert.pem |
  awk '$1~"^-----"{if(buf){print buf;buf=""};print;next}{buf=buf $0}END{printf("%s",buf)}' >freetsa_cacert.pem
  cat freetsa_cacert.pem
)
openssl x509 -reply -text -in /tmp/freetsa_cacert.pem # montrer les détails du certificat

## Élément de vérification 2 : encodage 64 du tsr validé par la TSA
# COPIER la ligne ci-dessous et COLLER dans le fichier /tmp/tsr.64
PLACEHOLDER - FICHIER NON HORODATÉ
base64 -d < /tmp/tsr.64 > /tmp/tsr.bin
openssl ts -reply -text -in /tmp/tsr.bin # montrer les détails de l'horodatage

## Élément de vérification 3 : fichier non horodaté sans payload (juste avant l'horodatage)
awk '/^### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}' < "\$nom_de_fichier.pdf" > /tmp/\$nom_de_fichier.pdf # fichier non signé sans payload

## Vérification finale : hash du fichier actuel et validation de la correspondance à l'aide du tsr et de la chaîne de certificats
# Lie le hash du fichier à la date du tsr dans la chaîne de confiance de la TSA
openssl ts -verify -in /tmp/tsr.bin -CAfile /tmp/freetsa_cacert.pem -data /tmp/\$nom_de_fichier.pdf # vérifier l'horodatage

### END SEALGOOD ###
EOD
}

########################
# Calcule un timestamp #
# <stdin               #
# >stdout : tsr.bin    #
########################
timestamp() {
  clean clean | openssl ts -query -data /dev/stdin -sha256 -cert |
  curl -s -H "Content-Type: application/timestamp-query" --data-binary @- --output - https://freetsa.org/tsr
}

###########################
# Calcule une signature   #
# <stdin                  #
# >stdout : signature.bin #
###########################
signraw() {
  clean clean >original_data
  if ((fdpassin)); then
    echo ask >&"$fdpassask"
    openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -rawin -in original_data -passin stdin <&"$fdpassin"
  else
    openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -rawin -in original_data
  fi
}

###########################
# Calcule une signature   #
# <stdin                  #
# >stdout : signature.bin #
###########################
signdgst(){
  # Cette signature n'est pas compatible avec le schéma de clé
  clean clean | openssl dgst -sha256 -binary >hash.bin
  if ((fdpassin)); then
    echo ask >&"$fdpassask"
    openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -in hash.bin -passin stdin <&"$fdpassin"
  else
    openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -in hash.bin
  fi
}

##############################################################
# Injection d'informations cachées dans une copie du fichier #
# <$1 : filetype                                             #
# <stdin                                                     #
# >stdout : copie avec payload & PLACEHOLDER                 #
##############################################################
inject_after_eod() {
  tee original_data
  [[ $1 =~ sealgood ]] || get_payload < original_data
}

############################################################################################################################
# Injection d'informations cachées dans une copie du fichier pdf                                                           #
# https://stackoverflow.com/questions/11896858/does-the-eof-in-a-pdf-have-to-appear-within-the-last-1024-bytes-of-the-file #
# Un peu limite mais pas rencontré de cas rhédibitoire et clean rend le pdf récupérable anyway                             #
# <$1 : filetype                                                                                                           #
# <stdin                                                                                                                   #
# >stdout : copie avec payload & PLACEHOLDER                                                                               #
############################################################################################################################
inject_pdf() {
  inject_after_eod "$@"
}

##################################################################
# Injection d'informations cachées dans une copie du HTML | XML  #
# <$1 : filetype                                                 #
# <stdin                                                         #
# >stdout : copie avec payload & PLACEHOLDER                     #
##################################################################
inject_xml() {
  tee original_data
  [[ $1 =~ sealgood ]] || echo "<!-- $(get_payload < original_data) -->"
}

##################################################################
# Injection d'informations cachées dans une copie du gzip        #
# https://www.gnu.org/software/gzip/manual/gzip#Advanced-usage   #
# <$1 : filetype                                                 #
# <stdin                                                         #
# >stdout : copie avec payload & PLACEHOLDER                     #
##################################################################
inject_gzip() {
  tee original_data
  [[ $1 =~ sealgood ]] || get_payload < original_data | gzip -c
}

###############################################################
# Sortie du script                                            #
# Prompt pour conserver le répertoire temporaire après verify #
# Désactivé par list2tgz en supprimant les fichiers           #
###############################################################
exit_policy(){
  [ -s tsr.bin ] || [ -s signature.bin ] &&
  </dev/tty read -r -p $'\n\033[1;36m=== Voulez-vous conserver le répertoire temporaire pour contrôle [yN] ? \033[0m' &&
  [[ $REPLY == y ]] &&
  warning "$PWD est conservé" &&
  ls -l >&2 ||
  rm -rf "$TMPDIR"
}

###########################################
# Scan l'input pour valider les actions   #
# <$1 : pour nommage de copie de l'entrée #
# <stdin                                  #
# >stdout : type de fichier               #
# >lookup.$1  : copie stdin               #
###########################################
lookup() {
  sfx=${1:-$RANDOM}
  cat >lookup."$sfx"
  local result="$(file -b -i lookup."$sfx")"
  if [[ $result =~ application/octet-stream ]];then
    if grep -aq '^%PDF-' lookup."$sfx" && grep -aq '^%%EOF' lookup."$sfx" ; then
      result="${result/octet-stream/pdf+octet-stream}"
    else
      result="${result/octet-stream/$(check_crypto_file "$sfx" "$result")+octet-stream}"
    fi
  fi
  if [[ $result =~ application/gzip ]];then
    if zgrep -aq '### BEGIN SEALGOOD' lookup."$sfx";then
      result="${result/gzip/sealgood+gzip}"
    fi
  elif [[ $result =~ text/xml ]];then
    if grep -aq '^<!-- ### BEGIN SEALGOOD' lookup."$sfx";then
      result="${result/xml/sealgood+xml}"
    fi
  elif [[ $result =~ text/html ]];then
    if grep -aq '^<!-- ### BEGIN SEALGOOD' lookup."$sfx";then
      result="${result/html/sealgood+html}"
    fi
  elif [[ $result =~ application/pdf ]];then
    if grep -aq '^### BEGIN SEALGOOD' lookup."$sfx";then
      result="${result/pdf/sealgood+pdf}"
    elif pdftotext lookup."$sfx" - 2>/dev/null | grep -aq '^### BEGIN SEALGOOD';then
      result="${result/pdf/sealgood-old+pdf}"
    fi
  elif [[ $result =~ text/plain ]];then
    if grep -aq '^-----BEGIN' lookup."$sfx";then
      result="${result/plain/$(check_crypto_file "$sfx" "$result")+plain}"
    fi
  fi
  if [[ ! $result =~ sealgood ]];then
    if grep -aq '^(<!-- )?### BEGIN SEALGOOD' lookup."$sfx";then
      result="${result/\//\/sealgood+}"
    fi
  fi
  echo "$result"
  [ "$sfx" = "$1" ] || rm -f lookup."$sfx"
}

###########################################
# Lookup des types de fichier crypto      #
# <$1 : pour nommage de copie de l'entrée #
# <$2 : known filetype                    #
# <lookup.$1                              #
# >stdout : type de fichier               #
###########################################
check_crypto_file() {
  local result=""
  if [[ $2 =~ octet-stream ]] ; then
    if (openssl pkcs12 -password pass: -in lookup."$1" -info -noout;(($?==1 || $?==0))) &>/dev/null ; then
      result="[PKCS#12] Conteneur de clé+certificat"
    elif (openssl x509 -password pass: -in lookup."$1" -noout;(($?==1 || $?==0))) &>/dev/null; then
      #local algo=$(openssl x509 -password pass: -in lookup."$1" -noout -text | grep "Public Key Algorithm")
      result="[X.509] Certificat"
    elif (openssl pkey -password pass: -in lookup."$1" -noout;(($?==1 || $?==0))) &>/dev/null; then
      #local algo=$(openssl pkey -in "$file" -noout -text | grep "algorithm")
      result="[PKEY] Clé privée"
    elif (openssl req -password pass: -in lookup."$1" -noout;(($?==1 || $?==0))) &>/dev/null; then
      result="[CSR] Demande de signature de certificat"
    fi
  elif [[ $2 =~ text/plain ]] ; then
    if grep -q "BEGIN CERTIFICATE REQUEST" lookup."$1"; then
      result="[CSR] Demande de signature de certificat"
    elif grep -q "BEGIN CERTIFICATE" lookup."$1"; then
      result="[PEM] Certificat"
    elif grep -q "BEGIN OPENSSH PRIVATE KEY" lookup."$1"; then
      result="[OPENSSH] Clé privée"
    elif grep -q "BEGIN PRIVATE KEY" lookup."$1"; then
      result="[PEM] Clé privée NON chiffrée"
    elif grep -q "BEGIN ENCRYPTED PRIVATE KEY" lookup."$1"; then
      result="[PEM] Clé privée chiffrée"
    elif grep -q "BEGIN PUBLIC KEY" lookup."$1"; then
      result="[PEM] Clé publique"
    elif grep -q "BEGIN RSA PUBLIC KEY" lookup."$1"; then
      result="[RSA] Clé publique"
    elif grep -q "BEGIN RSA PRIVATE KEY" lookup."$1"; then
      result="[RSA] Clé privée"
    elif gdalinfo lookup."$1" &>/dev/null; then
      result="Fichier DEM (format GDAL)"
    fi
  fi
  echo "$result"
}

#####################
# Envoi de messages #
#####################
die() {
  rc="$1"
  shift
  alert "$(basename "$0") rc=$rc $*"
  exit "$rc"
}
alert() {
  echo -e "\033[1;31mERREUR: $*\033[0m" >&2
}
step() {
  echo -e "\n\033[1;36m=== $* ===\033[0m" >&2
}
success() {
  echo -e "\033[1;32m$*\033[0m" >&2
}
warning() {
  echo -e "\033[1;33m$*\033[0m" >&2
}

###########################################################################################
# Principes de design :                                                                   #
# Un seul répertoire temporaire commun.                                                   #
# N'écrit aucun fichier hors du répertoire temporaire (sauf genkey)                       #
# Les fonctions principales sont conçues pour se composer en Unix pipe.                   #
# Pas d'éléments partagés entre fonctions, tout passe par le pipe, sauf exception.        #
# Chaque fonction contrôle la suite de son propre pipe.                                   #
# Chaque fonction commence par un fork décidant si elle doit s'exécuter ou être passante. #
# $args est consommée au fil du pipe.                                                     #
# L'ordre du pipe complet est :                                                           #
#                                                                                         #
# main | help | getkey | list2tgz | clean | inject | date | signe | verify | dead         #
#          \      \        \                                                              #
#            dead   dead     file2tgz | clean | inject | date | signe | verify | dead     #
###########################################################################################

################################
# Vérification des dépendances #
################################
for cmd in awk openssl base64 curl; do
  command -v $cmd &> /dev/null ||
  die 16 "$LINENO: Commande manquante: $cmd"
done </dev/null

myname="$(basename "$0")"
export TMPDIR="$(mktemp -d)"
trap exit_policy EXIT
cd "$TMPDIR" || die 16 "$LINENO: FATAL"
INITIAL_DIR="$OLDPWD"
shopt -s nullglob
list=("$HOME"/.ssh/ed25519_private*.pem)
export PRIVATE_KEY="${list[0]}" # nom local de la clé privée
list=("$HOME"/.ssh/ed25519_public*.pem)
export PUBLIC_KEY="${list[0]}" # nom local de la clé publique
export REPOS_KEY="$(cat < "$HOME"/.ssh/ed25519_public*.url)" # nom web de la clé publique

main "$@" | cat
