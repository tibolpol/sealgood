#!/bin/bash
################################################
# <$1 : genkey | sign | date                   #
# <stdin : data to sign | timestamp
# <$HOME/.ssh/ed25519_*.pem : Ed25519 keys     #
# <$HOME/.ssh/id_rsa.pub : identity clear text #
# >stdout : signed | timestamp data            #
# >stderr : errors                             #
################################################

myexit(){
  rc=$1
  shift
  echo "Error "$(basename "$0")" rc=$rc $*" >&2
  exit $rc
}

myname=$(basename $0)
mypath="$(readlink -f "$0")"
if [[ .$PWD != .$tmpdir ]]; then
  export tmpdir=$(mktemp -d)
  trap "rm -rf $tmpdir" exit
  cd $tmpdir
  cat > input.raw
fi

# Clés
PRIVATE_KEY=($HOME/.ssh/ed25519_private*.pem)
PUBLIC_KEY=($HOME/.ssh/ed25519_public*.pem)
REPOS_KEY="$(cat $HOME/.ssh/ed25519_public*.url)"

####################################
# Génération des clés ed25519      #
# > $HOME/.ssh/ed25519_private.pem #
# > $HOME/.ssh/ed25519_public.pem  #
####################################
genkeys() {
    [ -s $PRIVATE_KEY ] && myexit 4 "$PRIVATE_KEY existe déjà et a une taille non nulle"

    read -p"Cette clé servira à signer des documents, mentionnez le nom du signataire : " SIGNATAIRE

    PRIVATE_KEY=$HOME/.ssh/ed25519_private_${SIGNATAIRE// /_}.pem
    PUBLIC_KEY=$HOME/.ssh/ed25519_public_${SIGNATAIRE// /_}.pem

    [ -s $PRIVATE_KEY ] && myexit 4 "$PRIVATE_KEY existe déjà et a une taille non nulle"

    # 1. Générer la clé privée chiffrée avec AES-256
    # 2. Extraire la clé publique
    openssl genpkey -algorithm ed25519 -aes-256-cbc -out "$PRIVATE_KEY"
    openssl pkey -in "$PRIVATE_KEY" -pubout -out "$PUBLIC_KEY"

    fmt <<END
Vous pouvez (devez) diffuser $PUBLIC_KEY
sur un référentiel public de confiance, et mentionner son URL dans
$HOME/.ssh/ed25519_public_${SIGNATAIRE// /_}.url
Ainsi vos signatures de document seront non répudiables, donc acceptées.
END
}

#############################################################################
# PAYLOAD : Explications détaillées non intrusives sur les vues du document #
# C'est juste du plaintext qui commence et termine par délimiteurs          #
# >stdout : payload                                                         #
#############################################################################
get_payload() { cat <<EOD
### BEGIN SEALGOOD SIGNATURE ###

AVERTISSEMENT :  Comme dans la vraie vie, vérifier l'authenticité et la
signature est plus difficile que de signer.  L'essentiel est de garantir que
les moyens existent, qu'ils soient disponibles gratuitement et publiquement,
et qu'ils utilisent à chaque étape des outils reconnus, documentés et
standards, pour la transparence de la preuve.  Chaque étape est donc à
réaliser fastidieusement à la main à partir de ce guide.

Si l'élément de vérification 4 n'est pas un PLACEHOLDER mais un code de
signature en base64, l'identité du signataire peut être prouvée.

Déclaration de signataire : $(cut -d' ' -f3- < /home/tlp/.ssh/id_rsa.pub)

ATTENTION !  La déclaration de signataire lisible ici peut avoir été forgée. 
Ce qui fait foi est un tiers de confiance associé à cette clé (site web,
échange personnel, blockchain, etc.)

## Élément de vérification 1 :  URL de présentation de la clé, présentée par
# le signataire comme de confiance, afin que celui-ci ne fasse pas opposition
# à cette signature (non répudiation) :
# $REPOS_KEY

## Élément de vérification 2 : clé publique certifiant la clé privée du signataire
# COPIER trois lignes ci-dessous et COLLER dans le fichier /tmp/$(basename "$PUBLIC_KEY")
# ou télécharger $REPOS_KEY vers /tmp/$(basename "$PUBLIC_KEY")
-----BEGIN PUBLIC KEY-----
$(grep -v "PUBLIC KEY" "$PUBLIC_KEY" | tr -d '\n')
-----END PUBLIC KEY-----

## Élément de vérification 3 : fichier non signé sans payload (juste avant la signature)
awk '/^### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}' < "\$nom_de_fichier.pdf" > /tmp/\$nom_de_fichier.pdf # fichier non signé sans payload

## Élément de vérification 4 : signature du hash original du fichier
# COPIER la ligne ci-dessous et COLLER dans le fichier /tmp/sig.64
PLACEHOLDER - FICHIER NON SIGNÉ
base64 -d < /tmp/sig.64 > /tmp/sig.bin

## Vérification finale : hash du fichier actuel et validation de la correspondance à l'aide de la clé publique
# Lie le hash du fichier à la chaîne de confiance du possesseur de la clé privée
openssl pkeyutl -verify -pubin -inkey /tmp/\$(basename "\$PUBLIC_KEY") -sigfile /tmp/sig.bin -rawin -in /tmp/file.pdf # vérifier la signature

### BEGIN SEALGOOD TIMESTAMP ###

Si l'élément de vérification 2 n'est pas un PLACEHOLDER mais un code en
base64, la date de signature peut être prouvée.

Déclaration de signataire : $(cut -d' ' -f3- < /home/tlp/.ssh/id_rsa.pub)

## Élément de vérification 1 : certificat racine de l'autorité TSA
# COPIER les trois lignes ci-dessous et COLLER dans le fichier /tmp/freetsa_cacert.pem
# ou télécharger https://freetsa.org/files/cacert.pem vers /tmp/freetsa_cacert.pem
$(curl -s https://freetsa.org/files/cacert.pem | awk '$1~"^-----"{if(buf){print buf;buf=""};print;next}{buf=buf $0}END{printf("%s",buf)}')

## Élément de vérification 2 : encodage 64 du tsr validé par la TSA
# COPIER la ligne ci-dessous et COLLER dans le fichier /tmp/tsr.64
PLACEHOLDER - FICHIER NON HORODATÉ
base64 -d < /tmp/tsr.64 > /tmp/tsr.bin

## Élément de vérification 3 : fichier non horodaté sans payload (juste avant l'horodatage)
awk '/### END SEALGOOD SIGNATURE ###/{state=1}state{print}' < "\$nom_de_fichier.pdf" > /tmp/\$nom_de_fichier.pdf # fichier non signé sans payload

## Vérification finale : hash du fichier actuel et validation de la correspondance à l'aide du tsr et de la chaîne de certificats
# Lie le hash du fichier à la date du tsr dans la chaîne de confiance de la TSA
openssl ts -verify -in /tmp/tsr.bin -CAfile /tmp/freetsa_cacert.pem -data /tmp/\$nom_de_fichier.pdf # vérifier l'horodatage
openssl ts -reply -in tsr.bin -text -noout # monter les détails de l'horodatage 

### END SEALGOOD ###
EOD
}

########################
# Calcule un timestamp #
# <input.raw           #
# >stdout : tsr.bin    #
########################
timestamp(){
  clean | openssl ts -query -data /dev/stdin -sha256 -cert |
  curl -s -H "Content-Type: application/timestamp-query" --data-binary @- --output - https://freetsa.org/tsr
}

#########################
# Calcule une signature #
# <input.raw            #
# >signature.bin        #
#########################
signature(){
  clean > input.clean
  openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -rawin -in input.clean
}

##################################################################
# Injection d'informations cachées dans une copie du fichier pdf #
# <input.raw                                                     #
# >stdout : copie avec payload & PLACEHOLDER                     #
##################################################################
inject_after_eod() {
  cat input.raw
  filetype="$(lookup)"
  if [[ ! $filetype =~ sealgood ]];then
    get_payload
  fi
}

##############################################################
# Injection d'informations cachées dans une copie du fichier #
# <input.raw                                                 #
# >stdout : copie avec payload & PLACEHOLDER                 #
##############################################################
inject_info() {
  filetype="$(lookup)"
  if [[ $filetype =~ pdf ]];then
    inject_after_eod
  elif [[ $filetype =~ PEM..Clé.publique ]];then
    inject_after_eod
  fi
}

######################################################
# Signature d'un document (payload, hash, signature) #
# <input.raw                                         #
# <$PRIVATE_KEY                                      #
# >stdout : copie signée avec payload                #
######################################################
sign_doc() {
  if <injected grep -aq "^PLACEHOLDER.*SIGNÉ"; then
    grep -q "ENCRYPTED" "$PRIVATE_KEY" || myexit 4 "$PRIVATE_KEY non chiffrée" 
    <injected sed "s|^PLACEHOLDER.*SIGNÉ|$(signature | base64 -w 0)|"
  else
    echo "Déja signé" >&2
    cat injected
  fi
}

#######################################################
# Horodatage d'un document (payload, hash, signature) #
# <input.raw                                          #
# >stdout : copie horodatée avec payload              #
#######################################################
date_doc() {
  if <injected grep -aq "^PLACEHOLDER.*HORODATÉ"; then
    <injected sed "s|^PLACEHOLDER.*HORODATÉ|$(timestamp | base64 -w 0)|"
  else
    echo "Déja horodaté" >&2
    cat injected
  fi
}

######################################
# Lookup des types de fichier crypto #
# <input.raw                         #
# >stdout : type de fichier          #
######################################
check_crypto_file() {
  local result=""
  if [[ $1 =~ octet-stream ]] ; then
    if (openssl pkcs12 -password pass: -in input.raw -info -noout;(($?==1 || $?==0))) &>/dev/null ; then
      result="[PKCS#12] Conteneur de clé+certificat"
    elif (openssl x509 -password pass: -in input.raw -noout;(($?==1 || $?==0))) &>/dev/null; then
      #local algo=$(openssl x509 -password pass: -in input.raw -noout -text | grep "Public Key Algorithm")
      result="[X.509] Certificat"
    elif (openssl pkey -password pass: -in input.raw -noout;(($?==1 || $?==0))) &>/dev/null; then
      #local algo=$(openssl pkey -in "$file" -noout -text | grep "algorithm")
      result="[PKEY] Clé privée"
    elif (openssl req -password pass: -in input.raw -noout;(($?==1 || $?==0))) &>/dev/null; then
      result="[CSR] Demande de signature de certificat"
    fi
  elif [[ $1 =~ text/plain ]] ; then
    if grep -q "BEGIN CERTIFICATE REQUEST" input.raw; then
      result="[CSR] Demande de signature de certificat"
    elif grep -q "BEGIN CERTIFICATE" input.raw; then
      result="[PEM] Certificat"
    elif grep -q "BEGIN OPENSSH PRIVATE KEY" input.raw; then
      result="[OPENSSH] Clé privée"
    elif grep -q "BEGIN PRIVATE KEY" input.raw; then
      result="[PEM] Clé privée NON chiffrée"
    elif grep -q "BEGIN ENCRYPTED PRIVATE KEY" input.raw; then
      result="[PEM] Clé privée chiffrée"
    elif grep -q "BEGIN PUBLIC KEY" input.raw; then
      result="[PEM] Clé publique"
    elif grep -q "BEGIN RSA PUBLIC KEY" input.raw; then
      result="[RSA] Clé publique"
    elif grep -q "BEGIN RSA PRIVATE KEY" input.raw; then
      result="[RSA] Clé privée"
    elif gdalinfo input.raw &>/dev/null; then
      result="Fichier DEM (format GDAL)"
    fi
  fi
  echo "$result"
}

##################################
# Restitue le input.raw original #
# <input.raw                     #
# >stdout : original             #
##################################
clean(){
  awk '/^### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}' <input.raw
}

#########################################
# Scan l'input pour valider les actions #
# <input.raw                            #
# >stdout : type de fichier             #
#########################################
lookup(){
  local result="$(file -b -i input.raw)"
  if [[ $result =~ application/octet-stream ]];then
    if grep -aq '^%PDF-' input.raw && grep -aq '^%%EOF' input.raw ; then
      result="${result/octet-stream/pdf+octet-stream}"
    else
      result="${result/octet-stream/$(check_crypto_file "$result")+octet-stream}"
    fi
  fi
  if [[ $result =~ application/pdf ]];then
    if grep -aq '^### BEGIN SEALGOOD' input.raw;then
      result="${result/pdf/sealgood+pdf}"
    elif pdftotext input.raw - | grep -aq '^### BEGIN SEALGOOD';then
      result="${result/pdf/sealgood-old+pdf}"
    fi
  elif [[ $result =~ text/plain ]];then
    if grep -aq '^-----BEGIN' input.raw;then
      result="${result/plain/$(check_crypto_file "$result")+plain}"
    fi
  fi
  if [[ ! $result =~ sealgood ]];then
    if grep -aq '^### BEGIN SEALGOOD' input.raw;then
      result="${result/\//\/sealgood+}"
    fi
  fi
  echo "$result"
}

###########################################################
# MAIN                                                    #
# <$1 : opération (genkey | sign | date | inject | clean) #
# <stdin : input.raw                                      #
# >stdout : output.raw                                    #
###########################################################
case "$1" in
  genkeys)      genkeys                        ;;
  inject)       inject_info                    ;;
  date)         inject_info>injected;date_doc  ;;
  sign)         inject_info>injected;sign_doc  ;;
  clean)        clean                          ;;
  *)            result="$(lookup)"
                echo "Type of data: $result"
                if [[ $result =~ pdf ]];then
                  read -p "$myname { sign | date | inject | clean } ? " </dev/tty
                  exec "$mypath" "$REPLY"
                else
                  echo "Usage : $myname { genkeys | sign | date | inject | clean }"
                fi
                ;;
esac
