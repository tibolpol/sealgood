#!/bin/bash
################################################
# <$1 : genkey | sign | date                   #
# <stdin : data to sign | timestamp
# <$HOME/.ssh/ed25519_*.pem : Ed25519 keys     #
# <$HOME/.ssh/id_rsa.pub : identity clear text #
# >stdout : signed | timestamp data            #
# >stderr : errors                             #
################################################

die() {
  rc=$1
  shift
  alert "$(basename "$0") rc=$rc $*"
  exit $rc
}

alert() {
    echo -e "\033[1;31mERREUR: $*\033[0m" >&2
}

step() {
    echo -e "\n\033[1;36m=== $* ===\033[0m" >&2
}

success() {
    echo -e "\033[1;32m$*\033[0m" >&2
}

warning() {
    echo -e "\033[1;33m$*\033[0m" >&2
}

ret() {
  return $1
}

#############################
# <$1 : mot                 #
# <$* : autres              #
# >stdout : autres sans mot #
# >$? : présence mot        #
#############################
strip() {
    local word="$1"
    local input="${*:2}"  # Get all arguments after the first one
    if [[ "$input" =~ (^|[[:space:]])"$word"($|[[:space:]]) ]]; then
        echo -n "${input//$word/}"
        return 0
    else
        echo -n "$input"
        return 1
    fi
}

# Vérification des dépendances
for cmd in awk openssl base64; do
    if ! command -v $cmd &> /dev/null; then
        alert "Commande manquante: $cmd"
        exit 1
    fi
done </dev/null

exit_policy(){
    [ -s tsr.bin -o -s signature.bin ] &&
    </dev/tty read -p $'\n\033[1;36m=== Voulez-vous conserver le répertoire temporaire pour contrôle [yN] ? \033[0m' &&
    [[ $REPLY == y ]] &&
    warning "$TMPDIR est conservé" &&
    ls -l ||
    rm -rf "$TMPDIR"
}

myname=$(basename "$0")
mypath="$(readlink -f "$0")"

if [[ .$PWD != .$TMPDIR ]]; then
  export TMPDIR=$(mktemp -d)
  trap exit_policy EXIT
  cd $TMPDIR
fi </dev/null

# Clés
shopt -s nullglob
list=($HOME/.ssh/ed25519_private*.pem)
export PRIVATE_KEY="${list[0]}" # nom local de la clé privée
list=($HOME/.ssh/ed25519_public*.pem)
export PUBLIC_KEY="${list[0]}" # nom local de la clé publique
export REPOS_KEY="$(cat < $HOME/.ssh/ed25519_public*.url)" # nom web de la clé publique

####################################
# Génération des clés ed25519      #
# <stdin                           #
# <$* : fonctions à exécuter       #
# > $HOME/.ssh/ed25519_private.pem #
# > $HOME/.ssh/ed25519_public.pem  #
####################################
genkey() {
  strip genkey "$@" > args
  rargs=$?
  args="$(cat args)"
  if ret $rargs;then
    dead $args >/dev/null
    [ -s "$PRIVATE_KEY" ] && die 4 "$PRIVATE_KEY existe déjà et a une taille non nulle"

    read -p"Cette clé servira à signer des documents, mentionnez le nom du signataire : " SIGNATAIRE

    PRIVATE_KEY=$HOME/.ssh/ed25519_private_${SIGNATAIRE// /_}.pem
    PUBLIC_KEY=$HOME/.ssh/ed25519_public_${SIGNATAIRE// /_}.pem

    [ -s $PRIVATE_KEY ] && die 4 "$PRIVATE_KEY existe déjà et a une taille non nulle"

    # 1. Générer la clé privée chiffrée avec AES-256
    # 2. Extraire la clé publique
    openssl genpkey -algorithm ed25519 -aes-256-cbc -out "$PRIVATE_KEY"
    openssl pkey -in "$PRIVATE_KEY" -pubout -out "$PUBLIC_KEY"

    fmt <<END
Vous pouvez (devez) diffuser $PUBLIC_KEY
sur un référentiel public de confiance, et mentionner son URL dans
$HOME/.ssh/ed25519_public_${SIGNATAIRE// /_}.url
Ainsi vos signatures de document seront non répudiables, donc acceptées.
END
  else
    batch $args
  fi
}

##############################
# <stdin                     #
# <$* : fonctions à exécuter #
# >stdout : output.raw       #
##############################
batch() {
  strip batch "$@" > args
  rargs=$?
  args="$(cat args)"
  if ret $rargs;then
    while read FILE; do
      ((FNR++))
      if (cat < "$FILE" > input.batch) 2>/dev/null ;then
        if strip sign "$args" >/dev/null;then
          clean "$args" {fdpassin}< <(
            read -s -p "Mot de passe de la clé privée : " PASS
            while 1 ; do echo "$PASS"; done
          )
        else
          clean "$args"
        fi <input.batch
      else
        alert "stdin:$FNR: $FILE n'est pas lisible"
      fi
    done
  else
    cat | clean "$args"
  fi
}

######################################
# Restitue le input.raw sans payload #
# <stdin                             #
# <$* : fonctions à exécuter         #
# >stdout : original                 #
######################################
clean() {
  strip clean "$@" > args
  rargs=$?
  args="$(cat args)"
  if ret $rargs;then
    (
    awk '/^### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}'
    ) # | tee >(echo "clean output: $(lookup $LINENO)" >&2)
  else
    cat
  fi | inject "$args"
}

##############################################################
# Injection d'informations cachées dans une copie du fichier #
# <stdin                                                     #
# <$*     : fonctions à exécuter                             #
# >stdout : copie avec payload & PLACEHOLDER                 #
##############################################################
inject() {
  strip inject "$@" > args
  rargs=$?
  args="$(cat args)"
  if ret $rargs;then
    (
      filetype="$(lookup inject)"
      # Le type d'injection dépend de filetype
      if [[ $filetype =~ pdf ]];then
        inject_after_eod "$filetype"
      elif [[ $filetype =~ PEM..Clé.publique ]];then
        inject_after_eod "$filetype"
      else
        warning "Je ne sais pas injecter dans le mimetype : $filetype"
        cat
      fi <lookup.inject
    ) | tee >(echo "inject output: $(lookup $LINENO)" >&2)
  else
    cat
  fi | date "$args"
}

#######################################################
# Horodatage d'un document (payload, hash, signature) #
# <stdin                                              #
# <$* : fonctions à exécuter                          #
# >stdout : copie horodatée avec payload              #
#######################################################
date() {
  strip date "$@" > args
  rargs=$?
  args="$(cat args)"
  if ret $rargs;then
    (
      cat >input.date
      if grep -aq "^PLACEHOLDER.*HORODATÉ" input.date; then
        sed "s|^PLACEHOLDER.*HORODATÉ|$(timestamp | base64 -w 0)|" input.date
      else
        cat
        warning "Déjà horodaté"
      fi <input.date
    ) | tee >(echo "date output: $(lookup $LINENO)" >&2)
  else
    cat
  fi | sign "$args"
}

######################################################
# Signature d'un document (payload, hash, signature) #
# stdin   : data à signer                            #
# <$*     : fonctions à exécuter                     #
# <$PRIVATE_KEY : nom local de la clé privée         #
# >stdout : copie signée avec payload                #
######################################################
sign() {
  strip sign "$@" > args
  rargs=$?
  args="$(cat args)"
  if ret $rargs;then
    (
      cat >input.sign
      if <input.sign grep -aq "^PLACEHOLDER.*SIGNÉ"; then
        grep -q 'empty password' <(
          openssl pkey -in "$PRIVATE_KEY" -noout -passin pass: 2>&1
          ) || die 4 "$PRIVATE_KEY non chiffrée"
        sed "s|^PLACEHOLDER.*SIGNÉ|$(signature | base64 -w 0)|" input.sign
      else
        warning "Déjà signé"
        cat
      fi <input.sign
    ) | tee >(echo "sign output: $(lookup $LINENO)" >&2)
  else
    cat
  fi | verify "$args"
}

##################################################
# Vérification de sealgood signature & timestamp #
# <stdin  : data avec payload                    #
# <$*     : fonctions à exécuter                 #
# >stderr : statut de la vérification            #
# >stdout : copie de data                        #
##################################################
verify() {
  strip verify "$@" > args
  rargs=$?
  args="$(cat args)"
  if ret $rargs;then
    (
      cat >input.verify

      # Extraction des éléments du document
      step "Extraction des éléments de vérification"

      # 1. Extraction de la signature
      SIGNATURE=$(awk '/Élément de vérification 4 : signature du hash/,/base64/' input.verify | grep -vE '^#|base64|PLACEHOLDER' | tr -d ' \n')
      if [ -z "$SIGNATURE" ]; then
          warning "Signature introuvable dans le document"
      else
          echo "$SIGNATURE" | base64 -d > signature.bin
          success "Signature extraite et décodée"
          # 2. Extraction de la clé publique
          PUBLIC_KEY=$(awk '/-----BEGIN PUBLIC KEY-----/,/-----END PUBLIC KEY-----/' input.verify | head -n 3)
          if [ -z "$PUBLIC_KEY" ]; then
              warning "Clé publique introuvable dans le document"
          else
              echo "$PUBLIC_KEY" > public_key.pem
              success "Clé publique extraite"
          fi
      fi

      # 3. Extraction du TSR
      TSR=$(awk '/Élément de vérification 2 : encodage 64 du tsr/,/base64/' input.verify | grep -vE '^#|base64|PLACEHOLDER' | tr -d ' \n')
      if [ -z "$TSR" ]; then
          warning "TSR introuvable dans le document"
      else
          echo "$TSR" | base64 -d > tsr.bin
          success "TSR extrait et décodé"

          # 4. Extraction du certificat TSA
          TSA_CERT=$(awk '/-----BEGIN CERTIFICATE-----/,/-----END CERTIFICATE-----/' input.verify)
          if [ -z "$TSA_CERT" ]; then
              warning "Certificat TSA introuvable - Téléchargement depuis freetsa.org"
              curl -s https://freetsa.org/files/cacert.pem -o tsa_cert.pem || warning "Échec du téléchargement du certificat TSA"
          else
              echo "$TSA_CERT" > tsa_cert.pem
              success "Certificat TSA extrait"
          fi
      fi

      if [ -s tsa_cert.pem -o -s public_key.pem ]; then 

          # 5. Extraction du contenu original
          awk '/^### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}' input.verify > original_content
          success "Contenu original extrait"

          # Vérification de la signature
          if [ -s public_key.pem -a -s signature.bin -a -s original_content ]; then
              step "Vérification de la signature numérique"
              (
              set -x
              openssl pkeyutl -verify -pubin -inkey public_key.pem -sigfile signature.bin -rawin -in original_content &> sig_result
              )
              SIG_VERIFY=$?

              if (( SIG_VERIFY  == 0 )); then
                  success "Signature vérifiée avec succès"
                  SIGNATURE_VALID=true
              else
                  alert "Échec de la vérification de la signature"
                  cat sig_result
                  SIGNATURE_VALID=false
              fi
          fi

          # Vérification de l'horodatage
          if [ -s tsr.bin -a -s tsa_cert.pem -a -s original_content ] ; then
              step "Vérification de l'horodatage TSA"
              (
              set -x
              openssl ts -verify -in tsr.bin -CAfile tsa_cert.pem -data original_content &> ts_result
              )
              DATE_VERIFY=$?

              if (( DATE_VERIFY == 0 )); then
                  success "Horodatage vérifié avec succès"
                  TIMESTAMP_VALID=true
              else
                  alert "Échec de la vérification de l'horodatage"
                  cat ts_result
                  TIMESTAMP_VALID=false
              fi
                  
              # Affichage des détails de l'horodatage
              echo -e "\nDétails de l'horodatage:"
              openssl ts -reply -in tsr.bin -text | grep -A2 "Time stamp:"
          fi
      fi

      # Résumé final
      step "Résumé de la vérification"

      echo -e "Statut de la signature: $([ "$SIGNATURE_VALID" = true ] && echo "VALIDE" || { [ "$SIGNATURE_VALID" = false ] && echo "INVALIDE" || echo "ABSENT"; })"
      echo -e "Statut de l'horodatage: $([ "$TIMESTAMP_VALID" = true ] && echo "VALIDE" || { [ "$TIMESTAMP_VALID" = false ] && echo "INVALIDE" || echo "ABSENT"; })"

      # signé, horodaté et intact
      # signé et intact
      # horodaté et intact
      # ni signé ni horodaté 
      # altéré
      if   [ "$SIGNATURE_VALID" = true ] && [ "$TIMESTAMP_VALID" = true ]; then
          success "Le document est signé, horodaté et intact"
      elif [ "$SIGNATURE_VALID" = true ] && [ "$TIMESTAMP_VALID" = "" ]; then
          success "Le document est signé et intact"
      elif [ "$SIGNATURE_VALID" = ""   ] && [ "$TIMESTAMP_VALID" = true ]; then
          success "Le document est horodaté et intact"
      elif [ "$SIGNATURE_VALID" = ""   ] && [ "$TIMESTAMP_VALID" = "" ]; then
          warning "Le document n'est pas signé ni horodaté"
      else
          die 4 "Le document a été altéré"
      fi
      cat input.verify
    ) | tee >(echo "verify output: $(lookup $LINENO)" >&2)
  else
    cat
  fi | dead "$args"
}

dead(){
  (($# && $(eval echo -n $* | wc -c) )) && alert "Les arguments restants \"$*\" n'ont pas pu être traités"
  cat
}

#############################################################################
# PAYLOAD : Explications détaillées non intrusives sur les vues du document #
# C'est juste du plaintext qui commence et termine par des balises          #
# <$REPOS_KEY : nom web de la clé publique                                  #
# <$PUBLIC_KEY : nom local de la clé publique                               #
# <$HOME/.ssh/id_rsa.pub : emplacement du nom du signataire                 #
# <https://freetsa.org/files/cacert.pem : cartificat racine de la TSA       #
# >stdout : payload                                                         #
#############################################################################
get_payload() { cat <<EOD
### BEGIN SEALGOOD SIGNATURE ###
SealGood - The 100% DIY Document Authenticator
https://github.com/tibolpol/sealgood/

AVERTISSEMENT :  Comme pour un document matériel, vérifier l'authenticité et
la signature est plus difficile que de signer.  L'essentiel est de garantir
que les moyens existent, qu'ils soient disponibles gratuitement et
publiquement, et qu'ils utilisent à chaque étape des outils reconnus,
documentés et standards, pour la transparence de la preuve.  Chaque étape est
donc réalisable à la main à l'aide de ce guide. Une intégration légère est
proposée sur le site https://github.com/tibolpol/sealgood

Outils de vérification :
- standard POSIX : awk, base64, file, wc
- non POSIX mais standard reconnu : openssl

Le document signé a les propriétés suivantes :
file -bi : $(clean clean | lookup $LINENO)
wc       : $(clean clean | wc -)

Déclaration de signataire : $(cut -d' ' -f3- < $HOME/.ssh/id_rsa.pub)
Clé publique ed25519 du signataire : $REPOS_KEY

ATTENTION !  La déclaration de signataire lisible ici pourrait avoir été forgée.
Ce qui fait foi est le tiers de confiance associé à cette clé (site web,
échange personnel, blockchain, clé publique scellée et publiée sur
une adresse irrépudiable par le signataire).

La signature et l'horodatage restent valides tant que le contenu hors des
balises BEGIN SEALGOOD et END SEALGOOD n'est pas altéré.

Si l'élément de vérification 4 n'est pas un PLACEHOLDER mais un code de
signature en base64, l'identité du signataire peut être prouvée.

## Élément de vérification 1 :  URL de présentation de la clé, présentée par
# le signataire comme de confiance, afin que celui-ci ne fasse pas opposition
# à cette signature (non répudiation) :
# $REPOS_KEY

## Élément de vérification 2 :  clé publique ed25519 du signataire
# COPIER trois lignes ci-dessous et COLLER dans le fichier /tmp/$(basename "$PUBLIC_KEY")
# ou télécharger $REPOS_KEY vers /tmp/$(basename "$PUBLIC_KEY")
-----BEGIN PUBLIC KEY-----
$(awk '/^-----BEGIN PUBLIC KEY/{getline;print;exit}' "$PUBLIC_KEY")
-----END PUBLIC KEY-----

## Élément de vérification 3 : fichier non signé sans payload (juste avant la signature)
awk '/^### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}' < "\$nom_de_fichier.pdf" > /tmp/\$nom_de_fichier.pdf # fichier non signé sans payload

## Élément de vérification 4 : signature du hash original du fichier
# COPIER la ligne ci-dessous et COLLER dans le fichier /tmp/sig.64
PLACEHOLDER - FICHIER NON SIGNÉ
base64 -d < /tmp/sig.64 > /tmp/sig.bin

## Vérification finale : hash du fichier actuel et validation de la correspondance à l'aide de la clé publique
# Lie le hash du fichier à la chaîne de confiance du possesseur de la clé privée
openssl pkeyutl -verify -pubin -inkey /tmp/\$(basename "\$PUBLIC_KEY") -sigfile /tmp/sig.bin -rawin -in /tmp/file.pdf # vérifier la signature

### BEGIN SEALGOOD TIMESTAMP ###

Si l'élément de vérification 2 n'est pas un PLACEHOLDER mais un code en
base64, la date de signature peut être prouvée.

## Élément de vérification 1 : certificat racine de l'autorité TSA
# COPIER les trois lignes ci-dessous et COLLER dans le fichier /tmp/freetsa_cacert.pem
# ou télécharger https://freetsa.org/files/cacert.pem vers /tmp/freetsa_cacert.pem
$(curl -s https://freetsa.org/files/cacert.pem | awk '$1~"^-----"{if(buf){print buf;buf=""};print;next}{buf=buf $0}END{printf("%s",buf)}')
openssl x509 -reply -text -in /tmp/freetsa_cacert.pem # montrer les détails du certificat

## Élément de vérification 2 : encodage 64 du tsr validé par la TSA
# COPIER la ligne ci-dessous et COLLER dans le fichier /tmp/tsr.64
PLACEHOLDER - FICHIER NON HORODATÉ
base64 -d < /tmp/tsr.64 > /tmp/tsr.bin
openssl ts -reply -text -in /tmp/tsr.bin # montrer les détails de l'horodatage

## Élément de vérification 3 : fichier non horodaté sans payload (juste avant l'horodatage)
awk '/^### BEGIN SEALGOOD /{state=1}!state{print}/^### END SEALGOOD /{state=0}' < "\$nom_de_fichier.pdf" > /tmp/\$nom_de_fichier.pdf # fichier non signé sans payload

## Vérification finale : hash du fichier actuel et validation de la correspondance à l'aide du tsr et de la chaîne de certificats
# Lie le hash du fichier à la date du tsr dans la chaîne de confiance de la TSA
openssl ts -verify -in /tmp/tsr.bin -CAfile /tmp/freetsa_cacert.pem -data /tmp/\$nom_de_fichier.pdf # vérifier l'horodatage

### END SEALGOOD ###
EOD
}

########################
# Calcule un timestamp #
# <stdin               #
# >stdout : tsr.bin    #
########################
timestamp() {
  clean clean | openssl ts -query -data /dev/stdin -sha256 -cert |
  curl -s -H "Content-Type: application/timestamp-query" --data-binary @- --output - https://freetsa.org/tsr
}

###########################
# Calcule une signature   #
# <stdin                  #
# >stdout : signature.bin #
###########################
signature() {
  if ((fdpassin)); then
    openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -rawin -in <(clean clean) -passin stdin <&$fdpassin
  else
    openssl pkeyutl -sign -inkey "$PRIVATE_KEY" -rawin -in <(clean clean)
  fi
}

##################################################################
# Injection d'informations cachées dans une copie du fichier pdf #
# <$1 : filetype                                                 #
# <stdin                                                         #
# >stdout : copie avec payload & PLACEHOLDER                     #
##################################################################
inject_after_eod() {
  cat
  [[ $1 =~ sealgood ]] || get_payload
}

#########################################
# Scan l'input pour valider les actions #
# <$1 : step                            #
# <stdin                                #
# >stdout : type de fichier             #
# >lookup.$1  : copie stdin             #
#########################################
lookup() {
  cat >lookup.$1
  local result="$(file -b -i lookup.$1)"
  if [[ $result =~ application/octet-stream ]];then
    if grep -aq '^%PDF-' lookup.$1 && grep -aq '^%%EOF' lookup.$1 ; then
      result="${result/octet-stream/pdf+octet-stream}"
    else
      result="${result/octet-stream/$(check_crypto_file $1 "$result")+octet-stream}"
    fi
  fi
  if [[ $result =~ application/pdf ]];then
    if grep -aq '^### BEGIN SEALGOOD' lookup.$1;then
      result="${result/pdf/sealgood+pdf}"
    elif pdftotext lookup.$1 - | grep -aq '^### BEGIN SEALGOOD';then
      result="${result/pdf/sealgood-old+pdf}"
    fi
  elif [[ $result =~ text/plain ]];then
    if grep -aq '^-----BEGIN' lookup.$1;then
      result="${result/plain/$(check_crypto_file $1 "$result")+plain}"
    fi
  fi
  if [[ ! $result =~ sealgood ]];then
    if grep -aq '^### BEGIN SEALGOOD' lookup.$1;then
      result="${result/\//\/sealgood+}"
    fi
  fi
  echo "$result"
}

######################################
# Lookup des types de fichier crypto #
# <$1 : step                         #
# <$2 : known filetype
# <lookup.$1                         #
# >stdout : type de fichier          #
######################################
check_crypto_file() {
  local result=""
  if [[ $2 =~ octet-stream ]] ; then
    if (openssl pkcs12 -password pass: -in lookup.$1 -info -noout;(($?==1 || $?==0))) &>/dev/null ; then
      result="[PKCS#12] Conteneur de clé+certificat"
    elif (openssl x509 -password pass: -in lookup.$1 -noout;(($?==1 || $?==0))) &>/dev/null; then
      #local algo=$(openssl x509 -password pass: -in lookup.$1 -noout -text | grep "Public Key Algorithm")
      result="[X.509] Certificat"
    elif (openssl pkey -password pass: -in lookup.$1 -noout;(($?==1 || $?==0))) &>/dev/null; then
      #local algo=$(openssl pkey -in "$file" -noout -text | grep "algorithm")
      result="[PKEY] Clé privée"
    elif (openssl req -password pass: -in lookup.$1 -noout;(($?==1 || $?==0))) &>/dev/null; then
      result="[CSR] Demande de signature de certificat"
    fi
  elif [[ $2 =~ text/plain ]] ; then
    if grep -q "BEGIN CERTIFICATE REQUEST" lookup.$1; then
      result="[CSR] Demande de signature de certificat"
    elif grep -q "BEGIN CERTIFICATE" lookup.$1; then
      result="[PEM] Certificat"
    elif grep -q "BEGIN OPENSSH PRIVATE KEY" lookup.$1; then
      result="[OPENSSH] Clé privée"
    elif grep -q "BEGIN PRIVATE KEY" lookup.$1; then
      result="[PEM] Clé privée NON chiffrée"
    elif grep -q "BEGIN ENCRYPTED PRIVATE KEY" lookup.$1; then
      result="[PEM] Clé privée chiffrée"
    elif grep -q "BEGIN PUBLIC KEY" lookup.$1; then
      result="[PEM] Clé publique"
    elif grep -q "BEGIN RSA PUBLIC KEY" lookup.$1; then
      result="[RSA] Clé publique"
    elif grep -q "BEGIN RSA PRIVATE KEY" lookup.$1; then
      result="[RSA] Clé privée"
    elif gdalinfo lookup.$1 &>/dev/null; then
      result="Fichier DEM (format GDAL)"
    fi
  fi
  echo "$result"
}

###################################################################
# MAIN                                                            #
# <$* : opérations { genkey batch clean inject date sign verify } #
# <stdin : input.raw                                              #
# >stdout : output.raw                                            #
###################################################################
if (( $# ));then
  args="$*"
  args="${args//date/inject date}"
  args="${args//sign/inject sign}"
  genkey "$args"
else
  filetype="$(lookup main)"
  if [[ $filetype =~ pdf ]];then
    read -p "$myname { clean inject date sign verify } ? " </dev/tty
    [ -n "$REPLY" ] && choose $REPLY < lookup.main
  else
    echo "Input: $filetype" >&2
    echo "Usage : $myname { genkey batch clean inject date sign verify }" >&2
  fi
fi |
tee >(success "final output: $(lookup $LINENO)" >&2) |
cat
